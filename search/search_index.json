{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"napari-ndev (neuralDev)","text":"<p>A collection of widgets intended to serve any person seeking to process microscopy images from start to finish. The wide breadth of this plugin's scope is only made possible by the amazing libraries and plugins from the napari community, especially Robert Haase. Currently, the plugin supports the following goals:</p> <ol> <li>Image Utilities: Intended for high-throuput image-labeling and management, while passing down important metadata. Allows opening image files (preferably with <code>napari-aicsimageio</code> see Installation) and displaying in napari. Also reads metadata and allows customization prior to saving images and labels layers. Allows concatenation of image files and image layers for saving new images. Speeds up annotation by saving corresponding images and labels in designated folders. Also allows saving of shapes layers as labels in case shapes are being used as a region of interest.</li> <li>Workflow Widget: Batch pre-processing/processing images using napari-workflows.</li> <li>APOC Widget: Utilizes the excellent accelerated-pixel-and-object-classification (apoc) in a similar fashion to napari-apoc, but intended for batch training and prediction with a napari widget instead of scripting.<ul> <li>Custom Feature Set Widget: Generate a featureset to be used with the APOC widget. Also allows quick application in the napari viewer to an image layer to see all the features.</li> </ul> </li> <li>Measure Widget: Batch measurement of a label with optional corresponding image, label, and regions (ROIs) that can be used as an intensity image. Currently passed to <code>scikit-image.measure.regionprops</code>.</li> </ol>"},{"location":"#further-info","title":"Further Info","text":""},{"location":"#1-image-utilities","title":"1. Image Utilities","text":"<p>A quick and easy way to save annotations (a napari labels layer) and corresponding images to corresponding folders. Best if the images are opened with napari-aicsimageio--which can be as simple as drag and drop opening by setting the appropriate default reader for each file type in Preferences -&gt; Plugins--in order to utilize the metadata present for saving the image-label pairs. (See Note about bioio/AICSImageIO)</p> <p>Quick uniform adjustments to a folder of images, saving the output. Currently supports selecting channels, slicing Z, cropping/downsampling in XY, and doing a max projection of the sliced/cropped image data. To be added: alternative projection types, slicing in T, and compatibility with non TCZYX images (but this is not a priority since bioio and aicsimageio currently always extracts images as TCZYX even if a dim is only length 1.</p>"},{"location":"#2-workflow-widget","title":"2. Workflow Widget","text":"<p>Batch pre-processing/processing images using napari-workflows.  Images are processed outside the napari-viewer using aicsimageio as both reader and writer. Prior to passing the images to napari-workflows, the user selects the correct images as the roots (inputs) and thus napari-workflows matches the processing to create the outputs. The advantage of using napari-workflows for batch processing is that it provides an incredibly flexible processing interface without writing a novel widget for small changes to processing steps like specific filters, segmentation, or measurements. Currently only intended for use with images as inputs and images as outputs from napari-workflows, though there is future potential to have other outputs possible, such as .csv measurement arrays.</p>"},{"location":"#3-apoc-widget","title":"3. APOC Widget","text":"<p>Utilizes the excellent accelerated-pixel-and-object-classification (apoc) in a similar fashion to napari-apoc, but intended for batch training and prediction with a napari widget instead of scripting. Recognizes pre established feature set, and custom feature sets (a string of filters and radii) can be generated with a corresponding widget. Also contains a Custom Feature Set widget which allows application of all the features to a layer in the viewer, for improved visualization.</p>"},{"location":"#4-measure-widget","title":"4. Measure Widget","text":"<p>Batch measurements using scikit-image's regionprops. This can measure features of a label such as area, eccentricity, and more but also can measure various intensity metrics. Attempts to support post-processing of measurements, grouping, and more to make downstream analyses easier for users. Will be updated in the future to include nyxus.</p>"},{"location":"#a-note-about-bioioaicsimageio","title":"A Note about bioio/AICSImageIO","text":"<p>AICSImageIO is a convenient, multi-format file reader which also has the complimentary napari-aicsimageio reader plugin. However, the codebase is currently being switched over to bioio as the package matures; bioio is a replacement for AICSImageIO and will have less issues with compatibilities.</p> <p>By default, napari-aicsimageio installs all reader dependencies. Because napari-aicsimageio is not technically required for this plugin to work (you could build your own metadata for the annotation-saver) and just napari is required, the former is not an install requirement. This is to avoid using the GPL licence and to stick with BSD-3. However, you should install napari-aicsimageio if you want the smoothest operation of the widgets.</p>"},{"location":"installation/","title":"Installation","text":"<p>napari-ndev is a pure Python package, and can be installed with <code>pip</code>:</p> <pre><code>pip install napari-ndev\n</code></pre> <p>You may also like to install <code>napari-aicsimageio</code> to properly handle metadata with the <code>Image Utilities</code> widget.</p> <pre><code>pip install napari-aicsimageio\n</code></pre> <p>In addition, you may need to install specific <code>bioio</code> readers to support your specific image, such as <code>bioio-czi</code> or <code>bioio-lif</code>.</p>"},{"location":"api/helpers/","title":"Helpers","text":""},{"location":"api/helpers/#napari_ndev.helpers","title":"napari_ndev.helpers","text":"<p>Helper functions for file handling, image processing, and logging setup.</p> <p>Functions:</p> <ul> <li> <code>get_directory_and_files : Get the directory and files in the specified directory.</code>             \u2013              </li> <li> <code>get_channel_names : Get the channel names from an AICSImage or BioImage object.</code>             \u2013              </li> <li> <code>get_squeezed_dim_order : Return a string containing the squeezed dimensions of the given AICSImage or BioImage object.</code>             \u2013              </li> <li> <code>create_id_string : Create an ID string for the given image.</code>             \u2013              </li> <li> <code>check_for_missing_files : Check if the given files are missing in the specified directories.</code>             \u2013              </li> <li> <code>setup_logger : Set up a logger with the specified log location.</code>             \u2013              </li> </ul>"},{"location":"api/helpers/#napari_ndev.helpers.check_for_missing_files","title":"check_for_missing_files","text":"<pre><code>check_for_missing_files(files, *directories)\n</code></pre> <p>Check if the given files are missing in the specified directories.</p> <p>Parameters:</p> <ul> <li> <code>files</code>               (<code>list of Path or list of str</code>)           \u2013            <p>List of files to check.</p> </li> <li> <code>directories</code>               (<code>tuple of Path or str</code>, default:                   <code>()</code> )           \u2013            <p>Tuple of directories to search for the files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list of tuple</code>           \u2013            <p>List of tuples containing the missing files and their corresponding directories.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def check_for_missing_files(\n    files: list[Path] | list[str], *directories: Path | str\n) -&gt; list[tuple]:\n    \"\"\"Check if the given files are missing in the specified directories.\n\n    Parameters\n    ----------\n    files : list of Path or list of str\n        List of files to check.\n    directories : tuple of Path or str\n        Tuple of directories to search for the files.\n\n    Returns\n    -------\n    list of tuple\n        List of tuples containing the missing files and their corresponding directories.\n\n    \"\"\"\n    missing_files = []\n    for file in files:\n        for directory in directories:\n            if isinstance(directory, str):\n                directory = Path(directory)\n            if isinstance(file, str):\n                file = Path(file)\n\n            file_loc = directory / file.name\n            if not file_loc.exists():\n                missing_files.append((file.name, directory.name))\n\n    return missing_files\n</code></pre>"},{"location":"api/helpers/#napari_ndev.helpers.create_id_string","title":"create_id_string","text":"<pre><code>create_id_string(img, identifier)\n</code></pre> <p>Create an ID string for the given image.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>BioImage or AICSImage</code>)           \u2013            <p>The image object.</p> </li> <li> <code>identifier</code>               (<code>str</code>)           \u2013            <p>The identifier string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The ID string.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def create_id_string(img: BioImage | AICSImage, identifier: str) -&gt; str:\n    \"\"\"Create an ID string for the given image.\n\n    Parameters\n    ----------\n    img : BioImage or AICSImage\n        The image object.\n    identifier : str\n        The identifier string.\n\n    Returns\n    -------\n    str\n        The ID string.\n\n    \"\"\"\n    scene_idx = img.current_scene_index\n    # scene = img.current_scene\n    # instead use ome_metadata.name because this gets saved with OmeTiffWriter\n    try:\n        if img.ome_metadata.images[scene_idx].name is None:\n            scene = img.current_scene\n        else:\n            scene = img.ome_metadata.images[scene_idx].name\n    except NotImplementedError:\n        scene = img.current_scene  # not useful with OmeTiffReader, atm\n    id_string = f'{identifier}__{scene_idx}__{scene}'\n    return id_string\n</code></pre>"},{"location":"api/helpers/#napari_ndev.helpers.get_channel_names","title":"get_channel_names","text":"<pre><code>get_channel_names(img)\n</code></pre> <p>Get the channel names from an AICSImage object.</p> <p>If the image has a dimension order that includes \"S\" (it is RGB), return the default channel names [\"red\", \"green\", \"blue\"]. Otherwise, return the channel names from the image.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>AICSImage or BioImage</code>)           \u2013            <p>The AICSImage object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list of str</code>           \u2013            <p>The channel names.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def get_channel_names(img: AICSImage | BioImage) -&gt; list[str]:\n    \"\"\"Get the channel names from an AICSImage object.\n\n    If the image has a dimension order that includes \"S\" (it is RGB),\n    return the default channel names [\"red\", \"green\", \"blue\"].\n    Otherwise, return the channel names from the image.\n\n    Parameters\n    ----------\n    img : AICSImage or BioImage\n        The AICSImage object.\n\n    Returns\n    -------\n    list of str\n        The channel names.\n\n    \"\"\"\n    if 'S' in img.dims.order:\n        return ['red', 'green', 'blue']\n    return img.channel_names\n</code></pre>"},{"location":"api/helpers/#napari_ndev.helpers.get_directory_and_files","title":"get_directory_and_files","text":"<pre><code>get_directory_and_files(dir_path=None, pattern=None)\n</code></pre> <p>Get the directory and files in the specified directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>               (<code>str or Path or None</code>, default:                   <code>None</code> )           \u2013            <p>The directory path.</p> </li> <li> <code>pattern</code>               (<code>list of str or str or None</code>, default:                   <code>None</code> )           \u2013            <p>The file pattern(s) to match. If a string is provided, it will be treated as a single pattern. If a list is provided, each element will be treated as a separate pattern. Defaults to ['tif', 'tiff', 'nd2', 'czi', 'lif', 'oib', 'png', 'jpg', 'jpeg', 'bmp', 'gif'].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple of (Path, list of Path)</code>           \u2013            <p>A tuple containing the directory path and a list of file paths.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def get_directory_and_files(\n    dir_path: str | Path | None = None,\n    pattern: list[str] | str | None = None,\n) -&gt; tuple[Path, list[Path]]:\n    \"\"\"Get the directory and files in the specified directory.\n\n    Parameters\n    ----------\n    dir_path : str or Path or None, optional\n        The directory path.\n    pattern : list of str or str or None, optional\n        The file pattern(s) to match. If a string is provided, it will be treated as a single pattern.\n        If a list is provided, each element will be treated as a separate pattern.\n        Defaults to ['tif', 'tiff', 'nd2', 'czi', 'lif', 'oib', 'png', 'jpg', 'jpeg', 'bmp', 'gif'].\n\n    Returns\n    -------\n    tuple of (Path, list of Path)\n        A tuple containing the directory path and a list of file paths.\n\n    \"\"\"\n    if pattern is None:\n        pattern = ['tif', 'tiff', 'nd2', 'czi', 'lif', 'oib', 'png', 'jpg', 'jpeg', 'bmp', 'gif']\n    if dir_path is None:\n        return None, []\n\n    directory = Path(dir_path)\n\n    if dir_path is not None and not directory.exists():\n        raise FileNotFoundError(f'Directory {dir_path} does not exist.')\n\n    pattern = [pattern] if isinstance(pattern, str) else pattern\n    # add *. to each pattern if it doesn't already have either\n    pattern_glob = []\n    for pat in pattern:\n        if '.' not in pat:\n            pat = f'*.{pat}'\n        if '*' not in pat:\n            pat = f'*{pat}'\n        pattern_glob.append(pat)\n\n    files = []\n    for p_glob in pattern_glob:\n        for file in directory.glob(p_glob):\n            files.append(file)\n    return directory, files\n</code></pre>"},{"location":"api/helpers/#napari_ndev.helpers.get_squeezed_dim_order","title":"get_squeezed_dim_order","text":"<pre><code>get_squeezed_dim_order(img, skip_dims=None)\n</code></pre> <p>Return a string containing the squeezed dimensions of the given AICSImage object.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>AICSImage or BioImage</code>)           \u2013            <p>The AICSImage object.</p> </li> <li> <code>skip_dims</code>               (<code>list of str or str or None</code>, default:                   <code>None</code> )           \u2013            <p>Dimensions to skip. Defaults to [\"C\", \"S\"].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string containing the squeezed dimensions.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def get_squeezed_dim_order(\n    img: AICSImage | BioImage,\n    skip_dims: list[str] | str | None = None,\n) -&gt; str:\n    \"\"\"Return a string containing the squeezed dimensions of the given AICSImage object.\n\n    Parameters\n    ----------\n    img : AICSImage or BioImage\n        The AICSImage object.\n    skip_dims : list of str or str or None, optional\n        Dimensions to skip. Defaults to [\"C\", \"S\"].\n\n    Returns\n    -------\n    str\n        A string containing the squeezed dimensions.\n\n    \"\"\"\n    if skip_dims is None:\n        skip_dims = ['C', 'S']\n    return ''.join(\n        {k: v for k, v in img.dims.items() if v &gt; 1 and k not in skip_dims}\n    )\n</code></pre>"},{"location":"api/helpers/#napari_ndev.helpers.setup_logger","title":"setup_logger","text":"<pre><code>setup_logger(log_loc=Union[str, Path])\n</code></pre> <p>Set up a logger with the specified log location.</p> <p>Parameters:</p> <ul> <li> <code>log_loc</code>               (<code>str or Path</code>, default:                   <code>Union[str, Path]</code> )           \u2013            <p>The path to the log file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>logger</code> (              <code>Logger</code> )          \u2013            <p>The logger object.</p> </li> <li> <code>handler</code> (              <code>FileHandler</code> )          \u2013            <p>The file handler object.</p> </li> </ul> Source code in <code>src/napari_ndev/helpers.py</code> <pre><code>def setup_logger(log_loc=Union[str, Path]):\n    \"\"\"Set up a logger with the specified log location.\n\n    Parameters\n    ----------\n    log_loc : str or Path\n        The path to the log file.\n\n    Returns\n    -------\n    logger : logging.Logger\n        The logger object.\n    handler : logging.FileHandler\n        The file handler object.\n\n    \"\"\"\n    logger = logging.getLogger(__name__ + str(time.time()))\n    logger.setLevel(logging.INFO)\n    handler = logging.FileHandler(log_loc)\n    handler.setLevel(logging.INFO)\n    formatter = logging.Formatter('%(asctime)s - %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    return logger, handler\n</code></pre>"},{"location":"api/image_overview/","title":"Image Overview","text":""},{"location":"api/image_overview/#napari_ndev.image_overview","title":"napari_ndev.image_overview","text":"<p>Function and class to create and manage image overviews with stackview.</p> <p>It includes a function <code>image_overview</code> to generate an overview of images and a class <code>ImageOverview</code> to generate and save image overviews.</p>"},{"location":"api/image_overview/#napari_ndev.image_overview.ImageOverview","title":"ImageOverview","text":"<p>A class for generating and saving image overviews.</p> <p>Use this class to prevent a memory leak otherwise generated by the image_overview() function when show=True. For some reason, preventing the memory leak requires the use of a class instead of a function, and show=False.</p> Source code in <code>src/napari_ndev/image_overview.py</code> <pre><code>class ImageOverview:\n    \"\"\"A class for generating and saving image overviews.\n\n    Use this class to prevent a memory leak otherwise generated by the\n    image_overview() function when show=True. For some reason, preventing\n    the memory leak requires the use of a class instead of a function, and\n    show=False.\n    \"\"\"\n\n    def __init__(\n        self,\n        image_sets: list[dict],\n        xscale: float = 3,\n        yscale: float = 3,\n        image_title: str = '',\n        show: bool = False,\n    ):\n        \"\"\"Initialize an ImageOverivew object.\n\n        Parameters\n        ----------\n        image_sets : list of dict\n            A list of dictionaries containing image sets. See\n            `napari_ndev.image_overview` for more information.\n        xscale : float, optional\n            The scale factor for the x-axis. Default is 3.\n        yscale : float, optional\n            The scale factor for the y-axis. Default is 3.\n        image_title : str, optional\n            The title of the image overview. Default is an empty string.\n        show : bool, optional\n            Whether to display the generated overview. Default is False.\n            Prevents memory leak when False.\n\n        \"\"\"\n        plt.ioff()\n        self.fig = image_overview(image_sets, xscale, yscale, image_title)\n        if show:\n            plt.show()\n        plt.close()\n\n    def save(\n        self,\n        directory: str | None = None,\n        filename: str | None = None,\n    ):\n        \"\"\"Save the generated image overview with matplotlib.savefig.\n\n        Parameters\n        ----------\n        directory : str, optional\n            The directory to save the image overview. If not provided, the\n            current directory will be used.\n        filename : str, optional\n            The filename of the saved image overview. If not provided, a\n            default filename will be used.\n\n        \"\"\"\n        import pathlib\n\n        path_dir = pathlib.Path(directory)\n        path_dir.mkdir(parents=True, exist_ok=True)\n        filepath = path_dir / filename\n        self.fig.savefig(filepath)\n</code></pre>"},{"location":"api/image_overview/#napari_ndev.image_overview.ImageOverview.__init__","title":"__init__","text":"<pre><code>__init__(image_sets, xscale=3, yscale=3, image_title='', show=False)\n</code></pre> <p>Initialize an ImageOverivew object.</p> <p>Parameters:</p> <ul> <li> <code>image_sets</code>               (<code>list of dict</code>)           \u2013            <p>A list of dictionaries containing image sets. See <code>napari_ndev.image_overview</code> for more information.</p> </li> <li> <code>xscale</code>               (<code>float</code>, default:                   <code>3</code> )           \u2013            <p>The scale factor for the x-axis. Default is 3.</p> </li> <li> <code>yscale</code>               (<code>float</code>, default:                   <code>3</code> )           \u2013            <p>The scale factor for the y-axis. Default is 3.</p> </li> <li> <code>image_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the image overview. Default is an empty string.</p> </li> <li> <code>show</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display the generated overview. Default is False. Prevents memory leak when False.</p> </li> </ul> Source code in <code>src/napari_ndev/image_overview.py</code> <pre><code>def __init__(\n    self,\n    image_sets: list[dict],\n    xscale: float = 3,\n    yscale: float = 3,\n    image_title: str = '',\n    show: bool = False,\n):\n    \"\"\"Initialize an ImageOverivew object.\n\n    Parameters\n    ----------\n    image_sets : list of dict\n        A list of dictionaries containing image sets. See\n        `napari_ndev.image_overview` for more information.\n    xscale : float, optional\n        The scale factor for the x-axis. Default is 3.\n    yscale : float, optional\n        The scale factor for the y-axis. Default is 3.\n    image_title : str, optional\n        The title of the image overview. Default is an empty string.\n    show : bool, optional\n        Whether to display the generated overview. Default is False.\n        Prevents memory leak when False.\n\n    \"\"\"\n    plt.ioff()\n    self.fig = image_overview(image_sets, xscale, yscale, image_title)\n    if show:\n        plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/image_overview/#napari_ndev.image_overview.ImageOverview.save","title":"save","text":"<pre><code>save(directory=None, filename=None)\n</code></pre> <p>Save the generated image overview with matplotlib.savefig.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The directory to save the image overview. If not provided, the current directory will be used.</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The filename of the saved image overview. If not provided, a default filename will be used.</p> </li> </ul> Source code in <code>src/napari_ndev/image_overview.py</code> <pre><code>def save(\n    self,\n    directory: str | None = None,\n    filename: str | None = None,\n):\n    \"\"\"Save the generated image overview with matplotlib.savefig.\n\n    Parameters\n    ----------\n    directory : str, optional\n        The directory to save the image overview. If not provided, the\n        current directory will be used.\n    filename : str, optional\n        The filename of the saved image overview. If not provided, a\n        default filename will be used.\n\n    \"\"\"\n    import pathlib\n\n    path_dir = pathlib.Path(directory)\n    path_dir.mkdir(parents=True, exist_ok=True)\n    filepath = path_dir / filename\n    self.fig.savefig(filepath)\n</code></pre>"},{"location":"api/image_overview/#napari_ndev.image_overview.image_overview","title":"image_overview","text":"<pre><code>image_overview(image_sets, xscale=3, yscale=3, plot_title='')\n</code></pre> <p>Create an overview of images.</p> <p>Parameters:</p> <ul> <li> <code>image_sets</code>               (<code>list of dict</code>)           \u2013            <p>A list of dictionaries, each containing an image set. Each image set should be a dictionary containing the following keys: - image (list): A list of images to display. - title (list of str, optional): The title of the image set. - colormap (list of str, optional): The colormap to use.     \"labels\" will display the image as labels. - labels (list of bool, optional): Whether to display labels. - **kwargs: Additional keyword arguments to pass to stackview.imshow.</p> </li> <li> <code>xscale</code>               (<code>float</code>, default:                   <code>3</code> )           \u2013            <p>The x scale of the overview. Defaults to 3.</p> </li> <li> <code>yscale</code>               (<code>float</code>, default:                   <code>3</code> )           \u2013            <p>The y scale of the overview. Defaults to 3.</p> </li> <li> <code>plot_title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the plot. Defaults to an empty string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fig</code> (              <code>Figure</code> )          \u2013            <p>The matplotlib figure object containing the image overview.</p> </li> </ul> Source code in <code>src/napari_ndev/image_overview.py</code> <pre><code>def image_overview(\n    image_sets: list[dict],\n    xscale: float = 3,\n    yscale: float = 3,\n    plot_title: str = '',\n):\n    \"\"\"Create an overview of images.\n\n    Parameters\n    ----------\n    image_sets : list of dict\n        A list of dictionaries, each containing an image set. Each image set\n        should be a dictionary containing the following keys:\n        - image (list): A list of images to display.\n        - title (list of str, optional): The title of the image set.\n        - colormap (list of str, optional): The colormap to use.\n            \"labels\" will display the image as labels.\n        - labels (list of bool, optional): Whether to display labels.\n        - **kwargs: Additional keyword arguments to pass to stackview.imshow.\n    xscale : float, optional\n        The x scale of the overview. Defaults to 3.\n    yscale : float, optional\n        The y scale of the overview. Defaults to 3.\n    plot_title : str, optional\n        The title of the plot. Defaults to an empty string.\n\n    Returns\n    -------\n    fig : matplotlib.figure.Figure\n        The matplotlib figure object containing the image overview.\n\n    \"\"\"\n    # create the subplot grid\n    num_rows = len(image_sets)\n    num_columns = max([len(image_set['image']) for image_set in image_sets])\n    fig, axs = plt.subplots(\n        num_rows,\n        num_columns,\n        figsize=(num_columns * xscale, num_rows * yscale),\n    )\n\n    if num_rows == 1:\n        axs = [axs]\n    if num_columns == 1:\n        axs = [[ax] for ax in axs]\n\n    # iterate through the image sets\n    for row, image_set in enumerate(image_sets):\n        for col, _image in enumerate(image_set['image']):\n            # create a dictionary from the col-th values of each key\n            image_dict = {key: value[col] for key, value in image_set.items()}\n\n            # turn off the subplot and continue if there is no image\n            if image_dict.get('image') is None:\n                axs[row][col].axis('off')\n                continue\n\n            # create a labels key if it doesn't exist, but does in colormap\n            cmap = image_dict.get('colormap')\n            if cmap is not None and cmap.lower() == 'labels':\n                image_dict['labels'] = True\n\n            stackview.imshow(**image_dict, plot=axs[row][col])\n\n    plt.suptitle(plot_title, fontsize=16)\n    plt.tight_layout()\n    # plt.subplots_adjust(wspace=0.1, hspace=0.1)\n\n    return fig\n</code></pre>"},{"location":"api/measure/","title":"Measure","text":""},{"location":"api/measure/#napari_ndev.measure","title":"napari_ndev.measure","text":"<p>Functions for measuring properties of labels.</p> <p>Measure properties of labels in images using sci-kit image's regionprops. It includes utilities for handling label and intensity images, extracting information from ID strings, renaming intensity columns, and mapping treatment dictionaries to DataFrame ID columns.</p>"},{"location":"api/measure/#napari_ndev.measure.measure_regionprops","title":"measure_regionprops","text":"<pre><code>measure_regionprops(\n    label_images,\n    label_names=None,\n    intensity_images=None,\n    intensity_names=None,\n    properties=None,\n    scale=(1, 1),\n    id_string=None,\n    id_regex_dict=None,\n    tx_id=None,\n    tx_dict=None,\n    tx_n_well=None,\n    save_data_path=None,\n)\n</code></pre> <p>Measure properties of labels with sci-kit image regionprops.</p> <p>Optionally give a list of intensity_images to measure intensity properties of labels (i.e. 'intensity_mean', 'intensity_min', 'intensity_max', 'intensity_std'). If no label or intensity names are given, the names are automatically generated as a string of the input variable name. Choose from a list of properties to measure: [         \"area\",         \"area_convex\",         \"bbox\",         \"centroid\",         \"eccentricity\",         \"extent\",         \"feret_diameter_max\",         \"intensity_max\",         \"intensity_mean\",         \"intensity_min\",         \"intensity_std\",         \"num_pixels\",         \"orientation\",         \"perimeter\",         \"solidity\",     ].</p> <p>Parameters:</p> <ul> <li> <code>label_images</code>               (<code>list of ArrayLike or ArrayLike</code>)           \u2013            <p>The label images.</p> </li> <li> <code>label_names</code>               (<code>list of str or str or None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the label images.</p> </li> <li> <code>intensity_images</code>               (<code>list of ArrayLike or ArrayLike or None</code>, default:                   <code>None</code> )           \u2013            <p>The intensity images.</p> </li> <li> <code>intensity_names</code>               (<code>list of str or str or None</code>, default:                   <code>None</code> )           \u2013            <p>The names of the intensity images.</p> </li> <li> <code>properties</code>               (<code>list of str or None</code>, default:                   <code>None</code> )           \u2013            <p>The properties to measure.</p> </li> <li> <code>scale</code>               (<code>tuple of float</code>, default:                   <code>(1, 1)</code> )           \u2013            <p>The scale for the measurements.</p> </li> <li> <code>id_string</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>The ID string.</p> </li> <li> <code>id_regex_dict</code>               (<code>dict or None</code>, default:                   <code>None</code> )           \u2013            <p>The regex dictionary for extracting information from the ID string.</p> </li> <li> <code>tx_id</code>               (<code>str or None</code>, default:                   <code>None</code> )           \u2013            <p>The treatment ID.</p> </li> <li> <code>tx_dict</code>               (<code>dict or None</code>, default:                   <code>None</code> )           \u2013            <p>The treatment dictionary.</p> </li> <li> <code>tx_n_well</code>               (<code>int or None</code>, default:                   <code>None</code> )           \u2013            <p>The number of wells in the plate.</p> </li> <li> <code>save_data_path</code>               (<code>PathLike or None</code>, default:                   <code>None</code> )           \u2013            <p>The path to save the data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The DataFrame with measured properties.</p> </li> </ul> Source code in <code>src/napari_ndev/measure.py</code> <pre><code>def measure_regionprops(\n    label_images: list[ArrayLike] | ArrayLike,\n    label_names: list[str] | str | None = None,\n    intensity_images: list[ArrayLike] | ArrayLike | None = None,\n    intensity_names: list[str] | str | None = None,\n    properties: list[str] | None = None,\n    scale: tuple[float, float] | tuple[float, float, float] = (1, 1),\n    id_string: str | None = None,\n    id_regex_dict: dict | None = None,\n    tx_id: str | None = None,\n    tx_dict: dict | None = None,\n    tx_n_well: int | None = None,\n    save_data_path: PathLike = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Measure properties of labels with sci-kit image regionprops.\n\n    Optionally give a list of intensity_images to measure intensity properties\n    of labels (i.e. 'intensity_mean', 'intensity_min', 'intensity_max',\n    'intensity_std'). If no label or intensity names are given, the names are\n    automatically generated as a string of the input variable name.\n    Choose from a list of properties to measure: [\n            \"area\",\n            \"area_convex\",\n            \"bbox\",\n            \"centroid\",\n            \"eccentricity\",\n            \"extent\",\n            \"feret_diameter_max\",\n            \"intensity_max\",\n            \"intensity_mean\",\n            \"intensity_min\",\n            \"intensity_std\",\n            \"num_pixels\",\n            \"orientation\",\n            \"perimeter\",\n            \"solidity\",\n        ].\n\n    Parameters\n    ----------\n    label_images : list of ArrayLike or ArrayLike\n        The label images.\n    label_names : list of str or str or None, optional\n        The names of the label images.\n    intensity_images : list of ArrayLike or ArrayLike or None, optional\n        The intensity images.\n    intensity_names : list of str or str or None, optional\n        The names of the intensity images.\n    properties : list of str or None, optional\n        The properties to measure.\n    scale : tuple of float, optional\n        The scale for the measurements.\n    id_string : str or None, optional\n        The ID string.\n    id_regex_dict : dict or None, optional\n        The regex dictionary for extracting information from the ID string.\n    tx_id : str or None, optional\n        The treatment ID.\n    tx_dict : dict or None, optional\n        The treatment dictionary.\n    tx_n_well : int or None, optional\n        The number of wells in the plate.\n    save_data_path : PathLike or None, optional\n        The path to save the data.\n\n    Returns\n    -------\n    pd.DataFrame\n        The DataFrame with measured properties.\n\n    \"\"\"\n    from skimage import measure\n\n    if properties is None:\n        properties = ['area']\n    measure_dict = _generate_measure_dict(\n        label_images, label_names, intensity_images, intensity_names\n    )\n\n    if intensity_images is not None:\n        if len(measure_dict['intensity_images']) == 1:\n            intensity_stack = measure_dict['intensity_images'][0]\n        else:\n            intensity_stack = np.stack(\n                measure_dict['intensity_images'], axis=-1\n            )\n    else:\n        intensity_stack = None\n\n    measure_props = measure.regionprops_table(\n        label_image=measure_dict['label_images'][0],\n        intensity_image=intensity_stack,\n        properties=properties,\n        spacing=scale,\n    )\n\n    measure_df = pd.DataFrame(measure_props)\n\n    if intensity_names is not None:\n        measure_df = _rename_intensity_columns(\n            measure_df, measure_dict['intensity_names']\n        )\n\n    measure_df.insert(0, 'id', id_string)\n\n    if id_regex_dict is not None:\n        id_dict = _extract_info_from_id_string(id_string, id_regex_dict)\n        for key, value in id_dict.items():\n            measure_df.insert(1, key, value)\n\n    if tx_id is not None and tx_dict is not None:\n        _map_tx_dict_to_df_id_col(tx_dict, tx_n_well, measure_df, tx_id)\n\n    if save_data_path is not None:\n        measure_df.to_csv(save_data_path, index=False)\n\n    return measure_df\n</code></pre>"},{"location":"api/plate_mapper/","title":"PlateMapper","text":""},{"location":"api/plate_mapper/#napari_ndev._plate_mapper","title":"napari_ndev._plate_mapper","text":""},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper","title":"PlateMapper","text":"<p>A class for creating and manipulating plate maps.</p> <p>Attributes:</p> <ul> <li> <code>plate_size</code>               (<code>int</code>)           \u2013            <p>The size of the plate (e.g., 96, 384).</p> </li> <li> <code>wells</code>               (<code>dict</code>)           \u2013            <p>A dictionary mapping plate sizes to the number of rows and columns.</p> </li> <li> <code>plate_map</code>               (<code>DataFrame</code>)           \u2013            <p>The plate map DataFrame with well labels.</p> </li> <li> <code>plate_map_pivot</code>               (<code>DataFrame</code>)           \u2013            <p>The wide-formatted plate map DataFrame with treatments as columns.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__init__</code>             \u2013              <p>Initializes a PlateMapper object.</p> </li> <li> <code>create_empty_plate_map</code>             \u2013              <p>Creates an empty plate map DataFrame for a given plate size.</p> </li> <li> <code>assign_treatments</code>             \u2013              <p>Assigns treatments to specific wells in a plate map.</p> </li> <li> <code>get_pivoted_plate_map</code>             \u2013              <p>Pivots a plate map DataFrame to create a wide-formatted DataFrame with a single treatment as columns.</p> </li> <li> <code>get_styled_plate_map</code>             \u2013              <p>Styles a plate map DataFrame with different background colors for each unique value.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>class PlateMapper:\n    \"\"\"A class for creating and manipulating plate maps.\n\n    Attributes\n    ----------\n    plate_size : int\n        The size of the plate (e.g., 96, 384).\n    wells : dict\n        A dictionary mapping plate sizes to the number of rows and columns.\n    plate_map : pandas.DataFrame\n        The plate map DataFrame with well labels.\n    plate_map_pivot : pandas.DataFrame\n        The wide-formatted plate map DataFrame with treatments as columns.\n\n    Methods\n    -------\n    __init__(plate_size=96)\n        Initializes a PlateMapper object.\n    create_empty_plate_map()\n        Creates an empty plate map DataFrame for a given plate size.\n    assign_treatments(treatments)\n        Assigns treatments to specific wells in a plate map.\n    get_pivoted_plate_map(treatment)\n        Pivots a plate map DataFrame to create a wide-formatted DataFrame with a single treatment as columns.\n    get_styled_plate_map(treatment, palette='colorblind')\n        Styles a plate map DataFrame with different background colors for each unique value.\n\n    \"\"\"\n\n    def __init__(self, plate_size=96):\n        \"\"\"Initialize a PlateMapper object.\n\n        Parameters\n        ----------\n        plate_size : int, optional\n            The size of the plate. Defaults to 96.\n\n        \"\"\"\n        self.plate_size = plate_size\n        self.wells = {\n            6: (2, 3),\n            12: (3, 4),\n            24: (4, 6),\n            48: (6, 8),\n            96: (8, 12),\n            384: (16, 24),\n        }\n        self.plate_map = self.create_empty_plate_map()\n        self.plate_map_pivot = None\n\n    def create_empty_plate_map(self):\n        \"\"\"Create an empty plate map DataFrame for a given plate size.\n\n        Returns\n        -------\n        pandas.DataFrame\n            The empty plate map DataFrame with well labels.\n\n        \"\"\"\n        num_rows, num_columns = self.wells[self.plate_size]\n\n        row_labels = list(string.ascii_uppercase)[:num_rows]\n        column_labels = list(range(1, num_columns + 1))\n\n        well_rows = row_labels * num_columns\n        well_rows.sort()  # needed to sort the rows correctly\n        well_columns = column_labels * num_rows\n\n        well_labels_dict = {'row': well_rows, 'column': well_columns}\n\n        plate_map_df = pd.DataFrame(well_labels_dict)\n\n        plate_map_df['well_id'] = plate_map_df['row'] + plate_map_df[\n            'column'\n        ].astype(str)\n        self.plate_map = plate_map_df\n        return plate_map_df\n\n    def assign_treatments(self, treatments):\n        \"\"\"Assign treatments to specific wells in a plate map.\n\n        Parameters\n        ----------\n        treatments : dict\n            A dictionary mapping treatments to conditions and well ranges.\n\n        Returns\n        -------\n        pandas.DataFrame\n            The updated plate map with treatments assigned to specific wells.\n\n        \"\"\"\n        for treatment, conditions in treatments.items():\n            for condition, wells in conditions.items():\n                for well in wells:\n                    if ':' in well:\n                        start, end = well.split(':')\n                        start_row, start_col = start[0], int(start[1:])\n                        end_row, end_col = end[0], int(end[1:])\n                        well_condition = (\n                            (self.plate_map['row'] &gt;= start_row)\n                            &amp; (self.plate_map['row'] &lt;= end_row)\n                            &amp; (self.plate_map['column'] &gt;= start_col)\n                            &amp; (self.plate_map['column'] &lt;= end_col)\n                        )\n                    else:\n                        row, col = well[0], int(well[1:])\n                        well_condition = (self.plate_map['row'] == row) &amp; (\n                            self.plate_map['column'] == col\n                        )\n\n                    self.plate_map.loc[well_condition, treatment] = condition\n        return self.plate_map\n\n    def get_pivoted_plate_map(self, treatment):\n        \"\"\"Pivot a plate map DataFrame to create a wide-formatted DataFrame with a single treatment as columns.\n\n        Parameters\n        ----------\n        treatment : str\n            The column name of the treatment variable in the plate map DataFrame.\n\n        Returns\n        -------\n        pandas.DataFrame\n            The wide-formatted plate map DataFrame with treatments as columns.\n\n        \"\"\"\n        plate_map_pivot = self.plate_map.pivot(\n            index='row', columns='column', values=treatment\n        )\n        self.plate_map_pivot = plate_map_pivot\n        return plate_map_pivot\n\n    def get_styled_plate_map(self, treatment, palette='colorblind'):\n        \"\"\"Style a plate map with background colors for each unique value.\n\n        Parameters\n        ----------\n        treatment : str\n            The column name of the treatment variable in the plate map DataFrame.\n        palette : str or list, optional\n            The color palette to use for styling. Defaults to 'colorblind'.\n\n        Returns\n        -------\n        pandas.io.formats.style.Styler\n            The styled plate map DataFrame with different background colors for each unique value.\n\n        \"\"\"\n        from seaborn import color_palette\n\n        self.plate_map_pivot = self.get_pivoted_plate_map(treatment)\n\n        unique_values = pd.unique(self.plate_map_pivot.values.flatten())\n        unique_values = unique_values[pd.notna(unique_values)]\n\n        color_palette_hex = color_palette(palette).as_hex()\n        # Create an infinite iterator that cycles through the palette\n        palette_cycle = itertools.cycle(color_palette_hex)\n        # Use next() to get the next color\n        color_dict = {value: next(palette_cycle) for value in unique_values}\n\n        def get_background_color(value):\n            if pd.isna(value):\n                return ''\n            return f'background-color: {color_dict[value]}'\n\n        plate_map_styled = (\n            self.plate_map_pivot.style.applymap(get_background_color)\n            .set_caption(f'{treatment} Plate Map')\n            .format(lambda x: '' if pd.isna(x) else x)\n        )\n\n        return plate_map_styled\n</code></pre>"},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper.__init__","title":"__init__","text":"<pre><code>__init__(plate_size=96)\n</code></pre> <p>Initialize a PlateMapper object.</p> <p>Parameters:</p> <ul> <li> <code>plate_size</code>               (<code>int</code>, default:                   <code>96</code> )           \u2013            <p>The size of the plate. Defaults to 96.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>def __init__(self, plate_size=96):\n    \"\"\"Initialize a PlateMapper object.\n\n    Parameters\n    ----------\n    plate_size : int, optional\n        The size of the plate. Defaults to 96.\n\n    \"\"\"\n    self.plate_size = plate_size\n    self.wells = {\n        6: (2, 3),\n        12: (3, 4),\n        24: (4, 6),\n        48: (6, 8),\n        96: (8, 12),\n        384: (16, 24),\n    }\n    self.plate_map = self.create_empty_plate_map()\n    self.plate_map_pivot = None\n</code></pre>"},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper.assign_treatments","title":"assign_treatments","text":"<pre><code>assign_treatments(treatments)\n</code></pre> <p>Assign treatments to specific wells in a plate map.</p> <p>Parameters:</p> <ul> <li> <code>treatments</code>               (<code>dict</code>)           \u2013            <p>A dictionary mapping treatments to conditions and well ranges.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The updated plate map with treatments assigned to specific wells.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>def assign_treatments(self, treatments):\n    \"\"\"Assign treatments to specific wells in a plate map.\n\n    Parameters\n    ----------\n    treatments : dict\n        A dictionary mapping treatments to conditions and well ranges.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The updated plate map with treatments assigned to specific wells.\n\n    \"\"\"\n    for treatment, conditions in treatments.items():\n        for condition, wells in conditions.items():\n            for well in wells:\n                if ':' in well:\n                    start, end = well.split(':')\n                    start_row, start_col = start[0], int(start[1:])\n                    end_row, end_col = end[0], int(end[1:])\n                    well_condition = (\n                        (self.plate_map['row'] &gt;= start_row)\n                        &amp; (self.plate_map['row'] &lt;= end_row)\n                        &amp; (self.plate_map['column'] &gt;= start_col)\n                        &amp; (self.plate_map['column'] &lt;= end_col)\n                    )\n                else:\n                    row, col = well[0], int(well[1:])\n                    well_condition = (self.plate_map['row'] == row) &amp; (\n                        self.plate_map['column'] == col\n                    )\n\n                self.plate_map.loc[well_condition, treatment] = condition\n    return self.plate_map\n</code></pre>"},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper.create_empty_plate_map","title":"create_empty_plate_map","text":"<pre><code>create_empty_plate_map()\n</code></pre> <p>Create an empty plate map DataFrame for a given plate size.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The empty plate map DataFrame with well labels.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>def create_empty_plate_map(self):\n    \"\"\"Create an empty plate map DataFrame for a given plate size.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The empty plate map DataFrame with well labels.\n\n    \"\"\"\n    num_rows, num_columns = self.wells[self.plate_size]\n\n    row_labels = list(string.ascii_uppercase)[:num_rows]\n    column_labels = list(range(1, num_columns + 1))\n\n    well_rows = row_labels * num_columns\n    well_rows.sort()  # needed to sort the rows correctly\n    well_columns = column_labels * num_rows\n\n    well_labels_dict = {'row': well_rows, 'column': well_columns}\n\n    plate_map_df = pd.DataFrame(well_labels_dict)\n\n    plate_map_df['well_id'] = plate_map_df['row'] + plate_map_df[\n        'column'\n    ].astype(str)\n    self.plate_map = plate_map_df\n    return plate_map_df\n</code></pre>"},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper.get_pivoted_plate_map","title":"get_pivoted_plate_map","text":"<pre><code>get_pivoted_plate_map(treatment)\n</code></pre> <p>Pivot a plate map DataFrame to create a wide-formatted DataFrame with a single treatment as columns.</p> <p>Parameters:</p> <ul> <li> <code>treatment</code>               (<code>str</code>)           \u2013            <p>The column name of the treatment variable in the plate map DataFrame.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The wide-formatted plate map DataFrame with treatments as columns.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>def get_pivoted_plate_map(self, treatment):\n    \"\"\"Pivot a plate map DataFrame to create a wide-formatted DataFrame with a single treatment as columns.\n\n    Parameters\n    ----------\n    treatment : str\n        The column name of the treatment variable in the plate map DataFrame.\n\n    Returns\n    -------\n    pandas.DataFrame\n        The wide-formatted plate map DataFrame with treatments as columns.\n\n    \"\"\"\n    plate_map_pivot = self.plate_map.pivot(\n        index='row', columns='column', values=treatment\n    )\n    self.plate_map_pivot = plate_map_pivot\n    return plate_map_pivot\n</code></pre>"},{"location":"api/plate_mapper/#napari_ndev._plate_mapper.PlateMapper.get_styled_plate_map","title":"get_styled_plate_map","text":"<pre><code>get_styled_plate_map(treatment, palette='colorblind')\n</code></pre> <p>Style a plate map with background colors for each unique value.</p> <p>Parameters:</p> <ul> <li> <code>treatment</code>               (<code>str</code>)           \u2013            <p>The column name of the treatment variable in the plate map DataFrame.</p> </li> <li> <code>palette</code>               (<code>str or list</code>, default:                   <code>'colorblind'</code> )           \u2013            <p>The color palette to use for styling. Defaults to 'colorblind'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Styler</code>           \u2013            <p>The styled plate map DataFrame with different background colors for each unique value.</p> </li> </ul> Source code in <code>src/napari_ndev/_plate_mapper.py</code> <pre><code>def get_styled_plate_map(self, treatment, palette='colorblind'):\n    \"\"\"Style a plate map with background colors for each unique value.\n\n    Parameters\n    ----------\n    treatment : str\n        The column name of the treatment variable in the plate map DataFrame.\n    palette : str or list, optional\n        The color palette to use for styling. Defaults to 'colorblind'.\n\n    Returns\n    -------\n    pandas.io.formats.style.Styler\n        The styled plate map DataFrame with different background colors for each unique value.\n\n    \"\"\"\n    from seaborn import color_palette\n\n    self.plate_map_pivot = self.get_pivoted_plate_map(treatment)\n\n    unique_values = pd.unique(self.plate_map_pivot.values.flatten())\n    unique_values = unique_values[pd.notna(unique_values)]\n\n    color_palette_hex = color_palette(palette).as_hex()\n    # Create an infinite iterator that cycles through the palette\n    palette_cycle = itertools.cycle(color_palette_hex)\n    # Use next() to get the next color\n    color_dict = {value: next(palette_cycle) for value in unique_values}\n\n    def get_background_color(value):\n        if pd.isna(value):\n            return ''\n        return f'background-color: {color_dict[value]}'\n\n    plate_map_styled = (\n        self.plate_map_pivot.style.applymap(get_background_color)\n        .set_caption(f'{treatment} Plate Map')\n        .format(lambda x: '' if pd.isna(x) else x)\n    )\n\n    return plate_map_styled\n</code></pre>"},{"location":"api/widgets/apoc_widget/","title":"Apoc widget","text":""},{"location":"api/widgets/apoc_widget/#napari_ndev._apoc_container","title":"napari_ndev._apoc_container","text":""},{"location":"api/widgets/apoc_widget/#napari_ndev._apoc_container.ApocContainer","title":"ApocContainer","text":"<p>               Bases: <code>Container</code></p> <p>Container class for managing the ApocContainer widget in napari.</p> <p>Parameters:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer instance.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>_viewer</code>               (<code>Viewer</code>)           \u2013            <p>The napari viewer instance.</p> </li> <li> <code>_image_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting the image directory.</p> </li> <li> <code>_label_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting the label directory.</p> </li> <li> <code>_output_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting the output directory.</p> </li> <li> <code>_classifier_file</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting the classifier file.</p> </li> <li> <code>_classifier_type_mapping</code>               (<code>dict</code>)           \u2013            <p>Mapping of classifier types to their corresponding classes.</p> </li> <li> <code>_classifier_type</code>               (<code>RadioButtons</code>)           \u2013            <p>Widget for selecting the classifier type.</p> </li> <li> <code>_max_depth</code>               (<code>SpinBox</code>)           \u2013            <p>Widget for selecting the number of forests.</p> </li> <li> <code>_num_trees</code>               (<code>SpinBox</code>)           \u2013            <p>Widget for selecting the number of trees.</p> </li> <li> <code>_positive_class_id</code>               (<code>SpinBox</code>)           \u2013            <p>Widget for selecting the object label ID.</p> </li> <li> <code>_image_channels</code>               (<code>Select</code>)           \u2013            <p>Widget for selecting the image channels.</p> </li> <li> <code>_channel_order_label</code>               (<code>Label</code>)           \u2013            <p>Label widget for displaying the selected channel order.</p> </li> <li> <code>_PDFS</code>               (<code>Enum</code>)           \u2013            <p>Enum for predefined feature sets.</p> </li> <li> <code>_predefined_features</code>               (<code>ComboBox</code>)           \u2013            <p>Widget for selecting the features.</p> </li> <li> <code>_custom_features</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for entering custom feature string.</p> </li> <li> <code>_open_custom_feature_generator</code>               (<code>PushButton</code>)           \u2013            <p>Button for opening the custom feature generator widget.</p> </li> <li> <code>_continue_training</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox for indicating whether to continue training.</p> </li> <li> <code>_batch_train_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for training the classifier on image-label pairs.</p> </li> <li> <code>_batch_predict_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for predicting labels with the classifier.</p> </li> <li> <code>_progress_bar</code>               (<code>ProgressBar</code>)           \u2013            <p>Progress bar widget.</p> </li> <li> <code>_image_layer</code>               (<code>Select</code>)           \u2013            <p>Widget for selecting the image layers.</p> </li> <li> <code>_label_layer</code>               (<code>Widget</code>)           \u2013            <p>Widget for selecting the label layers.</p> </li> <li> <code>_train_image_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for training the classifier on selected layers using labels.</p> </li> <li> <code>_predict_image_layer</code>               (<code>PushButton</code>)           \u2013            <p>Button for predicting using the classifier on selected layers.</p> </li> <li> <code>_single_result_label</code>               (<code>Label</code>)           \u2013            <p>Label widget for displaying a single result.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>_update_metadata_from_file</code>             \u2013              <p>Update the metadata from the selected image directory.</p> </li> <li> <code>_update_channel_order</code>             \u2013              <p>Update the channel order label based on the selected image channels.</p> </li> <li> <code>_set_value_from_pattern</code>             \u2013              <p>Set the value from a pattern in the content.</p> </li> <li> <code>_process_classifier_metadata</code>             \u2013              <p>Process the classifier metadata from the content.</p> </li> <li> <code>_update_classifier_metadata</code>             \u2013              <p>Update the classifier metadata based on the selected classifier file.</p> </li> <li> <code>_classifier_statistics_table</code>             \u2013              <p>Display the classifier statistics table.</p> </li> <li> <code>_get_feature_set</code>             \u2013              <p>Get the selected feature set.</p> </li> <li> <code>_get_training_classifier_instance</code>             \u2013              <p>Get the training classifier instance based on the selected classifier type.</p> </li> <li> <code>_get_channel_image</code>             \u2013              <p>Get the channel image based on the selected channel index list.</p> </li> </ul> Source code in <code>src/napari_ndev/_apoc_container.py</code> <pre><code>class ApocContainer(Container):\n    \"\"\"Container class for managing the ApocContainer widget in napari.\n\n    Parameters\n    ----------\n    viewer : napari.viewer.Viewer\n        The napari viewer instance.\n\n    Attributes\n    ----------\n    _viewer : napari.viewer.Viewer\n        The napari viewer instance.\n\n    _image_directory : FileEdit\n        Widget for selecting the image directory.\n\n    _label_directory : FileEdit\n        Widget for selecting the label directory.\n\n    _output_directory : FileEdit\n        Widget for selecting the output directory.\n\n    _classifier_file : FileEdit\n        Widget for selecting the classifier file.\n\n    _classifier_type_mapping : dict\n        Mapping of classifier types to their corresponding classes.\n\n    _classifier_type : RadioButtons\n        Widget for selecting the classifier type.\n\n    _max_depth : SpinBox\n        Widget for selecting the number of forests.\n\n    _num_trees : SpinBox\n        Widget for selecting the number of trees.\n\n    _positive_class_id : SpinBox\n        Widget for selecting the object label ID.\n\n    _image_channels : Select\n        Widget for selecting the image channels.\n\n    _channel_order_label : Label\n        Label widget for displaying the selected channel order.\n\n    _PDFS : Enum\n        Enum for predefined feature sets.\n\n    _predefined_features : ComboBox\n        Widget for selecting the features.\n\n    _custom_features : LineEdit\n        Widget for entering custom feature string.\n\n    _open_custom_feature_generator : PushButton\n        Button for opening the custom feature generator widget.\n\n    _continue_training : CheckBox\n        Checkbox for indicating whether to continue training.\n\n    _batch_train_button : PushButton\n        Button for training the classifier on image-label pairs.\n\n    _batch_predict_button : PushButton\n        Button for predicting labels with the classifier.\n\n    _progress_bar : ProgressBar\n        Progress bar widget.\n\n    _image_layer : Select\n        Widget for selecting the image layers.\n\n    _label_layer : Widget\n        Widget for selecting the label layers.\n\n    _train_image_button : PushButton\n        Button for training the classifier on selected layers using labels.\n\n    _predict_image_layer : PushButton\n        Button for predicting using the classifier on selected layers.\n\n    _single_result_label : Label\n        Label widget for displaying a single result.\n\n    Methods\n    -------\n    _update_metadata_from_file()\n        Update the metadata from the selected image directory.\n\n    _update_channel_order()\n        Update the channel order label based on the selected image channels.\n\n    _set_value_from_pattern(pattern, content)\n        Set the value from a pattern in the content.\n\n    _process_classifier_metadata(content)\n        Process the classifier metadata from the content.\n\n    _update_classifier_metadata()\n        Update the classifier metadata based on the selected classifier file.\n\n    _classifier_statistics_table(custom_classifier)\n        Display the classifier statistics table.\n\n    _get_feature_set()\n        Get the selected feature set.\n\n    _get_training_classifier_instance()\n        Get the training classifier instance based on the selected classifier\n        type.\n\n    _get_channel_image(img, channel_index_list)\n        Get the channel image based on the selected channel index list.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        viewer: napari.viewer.Viewer = None,\n        # viewer = napari_viewer\n    ):\n        super().__init__()\n        self._viewer = viewer if viewer is not None else None\n        self._lazy_imports()\n        self._initialize_widgets()\n        self._initialize_batch_container()\n        self._initialize_viewer_container()\n        self._initialize_custom_apoc_container()\n        self._setup_widget_layout()\n        self._connect_events()\n\n    def _lazy_imports(self):\n        import apoc\n\n        self.apoc = apoc\n\n    def _filter_layers(self, layer_type):\n        # only do this if the viewer is not None\n        if self._viewer is None:\n            return []\n        return [x for x in self._viewer.layers if isinstance(x, layer_type)]\n\n    def _initialize_widgets(self):\n        self._classifier_file = FileEdit(\n            label='Classifier File (.cl)',\n            mode='r',\n            tooltip='Create a .txt file and rename it to .cl ending.',\n        )\n\n        self._continue_training = CheckBox(\n            label='Continue Training?',\n            value=True,\n            tooltip=(\n                'Continue training only matters if classifier already exists.'\n            ),\n        )\n\n        self._classifier_type_mapping = {\n            'PixelClassifier': self.apoc.PixelClassifier,\n            'ObjectSegmenter': self.apoc.ObjectSegmenter,\n        }\n\n        self._classifier_type = RadioButtons(\n            label='Classifier Type',\n            value='ObjectSegmenter',\n            choices=['ObjectSegmenter', 'PixelClassifier'],\n            tooltip='Object Segmenter is used for detecting objects of one '\n            'class, including connected components. '\n            'Pixel Classifier is used to classify pixel-types.',\n        )\n        self._max_depth = SpinBox(\n            label='Num. of Forests',\n            value=2,\n            max=20,\n            step=1,\n            tooltip='Increases training time for each forest',\n        )\n        self._num_trees = SpinBox(\n            label='Num. of Trees',\n            value=100,\n            step=50,\n            tooltip='Increases computational requirements.',\n        )\n        self._positive_class_id = SpinBox(\n            label='Object Label ID',\n            value=2,\n            step=1,\n            tooltip='Only used with ObjectSegmenter, otherwise ignored.',\n        )\n\n        self._PDFS = Enum(\n            'PDFS', self.apoc.PredefinedFeatureSet._member_names_\n        )\n        self._predefined_features = ComboBox(\n            label='Features',\n            choices=self._PDFS,\n            nullable=True,\n            value=None,\n            tooltip=\"All featuresets except 'custom' are premade\",\n        )\n        self._feature_string = LineEdit(\n            label='Feature String',\n            tooltip=(\n                'A string in the form of ' \"'filter1=radius1 filter2=radius2'.\"\n            ),\n        )\n\n    def _initialize_batch_container(self):\n        self._image_directory = FileEdit(label='Image Directory', mode='d')\n        self._label_directory = FileEdit(label='Label Directory', mode='d')\n        self._output_directory = FileEdit(label='Output Directory', mode='d')\n\n        self._image_channels = Select(\n            label='Image Channels',\n            choices=[],\n            tooltip=(\n                'Channel order should be same for training and prediction.'\n            ),\n        )\n        self._channel_order_label = Label(value='Select an Image Channel!')\n\n        self._batch_train_button = PushButton(label='Train')\n        self._batch_predict_button = PushButton(label='Predict')\n\n        self._batch_train_container = Container(\n            layout='horizontal',\n            # label=\"Train Classifier on Image-Label Pairs\",\n        )\n        self._batch_train_container.extend(\n            [self._label_directory, self._batch_train_button]\n        )\n\n        self._batch_predict_container = Container(\n            layout='horizontal',\n            # label=\"Predict Labels with Classifier on Images\"\n        )\n        self._batch_predict_container.extend(\n            [self._output_directory, self._batch_predict_button]\n        )\n\n        self._progress_bar = ProgressBar(label='Progress:')\n\n        self._batch_container = Container(layout='vertical')\n        self._batch_container.extend(\n            [\n                self._image_directory,\n                self._image_channels,\n                self._channel_order_label,\n                self._batch_train_container,\n                self._batch_predict_container,\n                self._progress_bar,\n            ]\n        )\n\n    def _initialize_viewer_container(self):\n        self._image_layers = Select(\n            choices=self._filter_layers(layers.Image),\n            label='Image Layers',\n        )\n        self._label_layer = ComboBox(\n            choices=self._filter_layers(layers.Labels),\n            label='Label Layer',\n        )\n        self._train_image_button = PushButton(\n            label='Train classifier on selected layers using label'\n        )\n        self._predict_image_layer = PushButton(\n            label='Predict using classifier on selected layers'\n        )\n        self._single_result_label = Label()\n\n        self._viewer_container = Container(layout='vertical')\n        self._viewer_container.extend(\n            [\n                self._image_layers,\n                self._label_layer,\n                self._train_image_button,\n                self._predict_image_layer,\n                self._single_result_label,\n            ]\n        )\n\n    def _initialize_custom_apoc_container(self):\n        from napari_ndev import ApocFeatureStack\n\n        self._custom_apoc_container = ApocFeatureStack(viewer=self._viewer)\n\n    def _setup_widget_layout(self):\n        # from napari_ndev import ApocFeatureStack\n        self.extend(\n            [\n                self._classifier_file,\n                self._continue_training,\n                self._classifier_type,\n                self._positive_class_id,\n                self._max_depth,\n                self._num_trees,\n                self._predefined_features,\n                self._feature_string,\n            ]\n        )\n\n        tabs = QTabWidget()\n        tabs.addTab(self._batch_container.native, 'Batch')\n        tabs.addTab(self._viewer_container.native, 'Viewer')\n        tabs.addTab(self._custom_apoc_container.native, 'Custom Feature Set')\n        self.native.layout().addWidget(tabs)\n\n    def _connect_events(self):\n        self._image_directory.changed.connect(self._update_metadata_from_file)\n        self._image_channels.changed.connect(self._update_channel_order)\n        self._classifier_file.changed.connect(self._update_classifier_metadata)\n\n        self._batch_train_button.clicked.connect(self.batch_train)\n        self._batch_predict_button.clicked.connect(self.batch_predict)\n        self._train_image_button.clicked.connect(self.image_train)\n        self._predict_image_layer.clicked.connect(self.image_predict)\n\n        self._custom_apoc_container._generate_string_button.clicked.connect(\n            self.insert_custom_feature_string\n        )\n        self._predefined_features.changed.connect(self._get_feature_set)\n\n        # when self._viewer.layers is updated, update the choices in the ComboBox\n        if self._viewer is not None:\n            self._viewer.layers.events.removed.connect(\n                self._update_layer_choices\n            )\n            self._viewer.layers.events.inserted.connect(\n                self._update_layer_choices\n            )\n\n    def _update_layer_choices(self):\n        self._label_layer.choices = self._filter_layers(layers.Labels)\n        self._image_layers.choices = self._filter_layers(layers.Image)\n\n    def _update_metadata_from_file(self):\n        from aicsimageio import AICSImage\n\n        _, files = helpers.get_directory_and_files(self._image_directory.value)\n        img = AICSImage(files[0])\n        self._image_channels.choices = helpers.get_channel_names(img)\n\n    def _update_channel_order(self):\n        self._channel_order_label.value = 'Selected Channel Order: ' + str(\n            self._image_channels.value\n        )\n\n    ##############################\n    # Classifier Related Functions\n    ##############################\n    def _set_value_from_pattern(self, pattern, content):\n        match = re.search(pattern, content)\n        return match.group(1) if match else None\n\n    def _process_classifier_metadata(self, content):\n        self._classifier_type.value = self._set_value_from_pattern(\n            r'classifier_class_name\\s*=\\s*([^\\n]+)', content\n        )\n        self._max_depth.value = self._set_value_from_pattern(\n            r'max_depth\\s*=\\s*(\\d+)', content\n        )\n        self._num_trees.value = self._set_value_from_pattern(\n            r'num_trees\\s*=\\s*(\\d+)', content\n        )\n        self._positive_class_id.value = (\n            self._set_value_from_pattern(\n                r'positive_class_identifier\\s*=\\s*(\\d+)', content\n            )\n            or 2\n        )\n\n    def _update_classifier_metadata(self):\n        with open(self._classifier_file.value) as file:\n            content = file.read()\n\n        # Ignore rest of function if file contents are empty\n        if not content.strip():\n            return\n\n        self._process_classifier_metadata(content)\n\n        if self._classifier_type.value in self._classifier_type_mapping:\n            classifier_class = self._classifier_type_mapping[\n                self._classifier_type.value\n            ]\n            custom_classifier = classifier_class(\n                opencl_filename=self._classifier_file.value\n            )\n        else:\n            custom_classifier = None\n\n        self._classifier_statistics_table(custom_classifier)\n\n    def _classifier_statistics_table(self, custom_classifier):\n        table, _ = custom_classifier.statistics()\n\n        trans_table = {'filter_name': [], 'radius': []}\n\n        for value in table:\n            filter_name, radius = (\n                value.split('=') if '=' in value else (value, 0)\n            )\n            trans_table['filter_name'].append(filter_name)\n            trans_table['radius'].append(int(radius))\n\n        for i in range(len(next(iter(table.values())))):\n            trans_table[str(i)] = [round(table[key][i], 2) for key in table]\n\n        table_df = pd.DataFrame.from_dict(trans_table)\n        if self._viewer is not None:\n            self._viewer.window.add_dock_widget(\n                Table(value=table_df),\n                name=os.path.basename(self._classifier_file.value),\n            )\n\n    def _get_feature_set(self):\n        if self._predefined_features.value.value == 1:\n            feature_set = ''\n        else:\n            feature_set = self.apoc.PredefinedFeatureSet[\n                self._predefined_features.value.name\n            ].value\n        self._feature_string.value = feature_set\n        self._custom_apoc_container._feature_string.value = (\n            feature_set  # &lt;- potentially deprecated in future\n        )\n        return feature_set\n\n    def _get_training_classifier_instance(self):\n        if self._classifier_type.value == 'PixelClassifier':\n            return self.apoc.PixelClassifier(\n                opencl_filename=self._classifier_file.value,\n                max_depth=self._max_depth.value,\n                num_ensembles=self._num_trees.value,\n            )\n\n        if self._classifier_type.value == 'ObjectSegmenter':\n            return self.apoc.ObjectSegmenter(\n                opencl_filename=self._classifier_file.value,\n                positive_class_identifier=self._positive_class_id.value,\n                max_depth=self._max_depth.value,\n                num_ensembles=self._num_trees.value,\n            )\n        return None\n\n    ##############################\n    # Training and Prediction\n    ##############################\n    def _get_channel_image(self, img, channel_index_list):\n        if 'S' in img.dims.order:\n            channel_img = img.get_image_data('TSZYX', S=channel_index_list)\n        else:\n            channel_img = img.get_image_data('TCZYX', C=channel_index_list)\n        return channel_img\n\n    def batch_train(self):\n        from aicsimageio import AICSImage\n\n        image_directory, image_files = helpers.get_directory_and_files(\n            self._image_directory.value\n        )\n        label_directory, _ = helpers.get_directory_and_files(\n            self._label_directory.value\n        )\n        # missing_files = check_for_missing_files(image_files, label_directory)\n\n        log_loc = self._classifier_file.value.with_suffix('.log.txt')\n        logger, handler = helpers.setup_logger(log_loc)\n\n        logger.info(\n        \"\"\"\n        Classifier: %s\n        Channels: %s\n        Num. Files: %d\n        Image Directory: %s\n        Label Directory: %s\n        \"\"\",\n        self._classifier_file.value,\n        self._image_channels.value,\n        len(image_files),\n        image_directory,\n        label_directory\n    )\n\n        # https://github.com/clEsperanto/pyclesperanto_prototype/issues/163\n        set_wait_for_kernel_finish(True)\n\n        self._progress_bar.label = f'Training on %s {len(image_files)} Images'\n        self._progress_bar.value = 0\n        self._progress_bar.max = len(image_files)\n\n        if not self._continue_training:\n            self.apoc.erase_classifier(self._classifier_file.value)\n\n        custom_classifier = self._get_training_classifier_instance()\n        feature_set = self._feature_string.value\n\n        channel_index_list = [\n            self._image_channels.choices.index(channel)\n            for channel in self._image_channels.value\n        ]\n\n        # Iterate over image files, only pulling label files with an identical\n        # name to the image file. Ensuring that files match by some other\n        # method would be much more complicated, so I'm leaving it up to the\n        # user at this point. In addition, the utilities widget saves with\n        # the same name, so this should be a non-issue, if staying within the\n        # same workflow.\n        for idx, image_file in enumerate(image_files):\n            if not (label_directory / image_file.name).exists():\n                logger.error('Label file missing for %s', image_file.name)\n                self._progress_bar.value = idx + 1\n                continue\n\n            logger.info('Training Image %d: %s', idx+1, image_file.name)\n\n            img = AICSImage(image_directory / image_file.name)\n            channel_img = self._get_channel_image(img, channel_index_list)\n\n            lbl = AICSImage(label_directory / image_file.name)\n            label = lbl.get_image_data('TCZYX', C=0)\n\n            # &lt;- this is where setting up dask processing would be useful\n\n            try:\n                custom_classifier.train(\n                    features=feature_set,\n                    image=np.squeeze(channel_img),\n                    ground_truth=np.squeeze(label),\n                    continue_training=True,\n                )\n                self._progress_bar.value = idx + 1\n            except Exception:\n                logger.exception('Error training %s', image_file)\n                self._progress_bar.value = idx + 1\n                continue\n\n        self._classifier_statistics_table(custom_classifier)\n        self._progress_bar.label = f'Trained on {len(image_files)} Images'\n        logger.removeHandler(handler)\n\n    def _get_prediction_classifier_instance(self):\n        if self._classifier_type.value in self._classifier_type_mapping:\n            classifier_class = self._classifier_type_mapping[\n                self._classifier_type.value\n            ]\n            return classifier_class(\n                opencl_filename=self._classifier_file.value\n            )\n        return None\n\n    def batch_predict(self):\n        from aicsimageio import AICSImage\n        from aicsimageio.writers import OmeTiffWriter\n\n        image_directory, image_files = helpers.get_directory_and_files(\n            dir_path=self._image_directory.value,\n        )\n\n        log_loc = self._output_directory.value / 'log.txt'\n        logger, handler = helpers.setup_logger(log_loc)\n\n        logger.info(\n        \"\"\"\n        Classifier: %s\n        Channels: %s\n        Num. Files: %d\n        Image Directory: %s\n        Output Directory: %s\n        \"\"\",\n        self._classifier_file.value,\n        self._image_channels.value,\n        len(image_files),\n        image_directory,\n        self._output_directory.value\n    )\n\n        # https://github.com/clEsperanto/pyclesperanto_prototype/issues/163\n        set_wait_for_kernel_finish(True)\n\n        self._progress_bar.label = f'Predicting {len(image_files)} Images'\n        self._progress_bar.value = 0\n        self._progress_bar.max = len(image_files)\n\n        custom_classifier = self._get_prediction_classifier_instance()\n\n        channel_index_list = [\n            self._image_channels.choices.index(channel)\n            for channel in self._image_channels.value\n        ]\n\n        for idx, file in enumerate(image_files):\n            logger.info('Predicting Image %d: %s', idx+1, file.name)\n\n            img = AICSImage(file)\n            channel_img = self._get_channel_image(img, channel_index_list)\n            squeezed_dim_order = helpers.get_squeezed_dim_order(img)\n\n            # &lt;- this is where setting up dask processing would be useful\n\n            try:\n                result = custom_classifier.predict(\n                    image=np.squeeze(channel_img)\n                )\n            except Exception:\n                logger.exception('Error predicting %s', file)\n                self._progress_bar.value = idx + 1\n                continue\n\n            save_data = np.asarray(result)\n            if save_data.max() &gt; 65535:\n                save_data = save_data.astype(np.int32)\n            else:\n                save_data = save_data.astype(np.int16)\n\n            OmeTiffWriter.save(\n                data=save_data,\n                uri=self._output_directory.value / (file.stem + '.tiff'),\n                dim_order=squeezed_dim_order,\n                channel_names=['Labels'],\n                physical_pixel_sizes=img.physical_pixel_sizes,\n            )\n            del result\n\n            self._progress_bar.value = idx + 1\n\n        self._progress_bar.label = f'Predicted {len(image_files)} Images'\n        logger.removeHandler(handler)\n\n    def image_train(self):\n        image_names = [image.name for image in self._image_layers.value]\n        label_name = self._label_layer.value.name\n        self._single_result_label.value = (\n            f'Training on {image_names} using {label_name}'\n        )\n\n        image_list = [image.data for image in self._image_layers.value]\n        image_stack = np.stack(image_list, axis=0)\n        label = self._label_layer.value.data\n\n        # https://github.com/clEsperanto/pyclesperanto_prototype/issues/163\n        set_wait_for_kernel_finish(True)\n\n        if not self._continue_training:\n            self.apoc.erase_classifier(self._classifier_file.value)\n\n        custom_classifier = self._get_training_classifier_instance()\n        feature_set = self._feature_string.value\n\n        custom_classifier.train(\n            features=feature_set,\n            image=np.squeeze(image_stack),\n            ground_truth=np.squeeze(label),\n            continue_training=True,\n        )\n\n        self._single_result_label.value = (\n            f'Trained on {image_names} using {label_name}'\n        )\n\n    def image_predict(self):\n        set_wait_for_kernel_finish(\n            True\n        )  # https://github.com/clEsperanto/pyclesperanto_prototype/issues/163\n\n        image_names = [image.name for image in self._image_layers.value]\n        self._single_result_label.value = f'Predicting {image_names}'\n        image_list = [image.data for image in self._image_layers.value]\n        image_stack = np.stack(image_list, axis=0)\n        scale = self._image_layers.value[0].scale\n\n        custom_classifier = self._get_prediction_classifier_instance()\n\n        result = custom_classifier.predict(image=np.squeeze(image_stack))\n\n        # sometimes, input layers may have shape with 1s, like (1,1,10,10)\n        # however, we are squeezing the input, so the reuslt will have shape\n        # (10,10), and therefore scale needs to accomodate dropped axes\n        result_dims = result.ndim\n        if len(scale) &gt; result_dims:\n            scale = scale[-result_dims:]\n\n        self._viewer.add_labels(result, scale=scale)\n\n        self._single_result_label.value = f'Predicted {image_names}'\n\n        return result\n\n    def insert_custom_feature_string(self):\n        self._feature_string.value = (\n            self._custom_apoc_container._feature_string.value\n        )\n        return self._feature_string.value\n</code></pre>"},{"location":"api/widgets/custom_apoc_feature_set/","title":"Custom apoc feature set","text":""},{"location":"api/widgets/custom_apoc_feature_set/#napari_ndev._apoc_feature_stack","title":"napari_ndev._apoc_feature_stack","text":""},{"location":"api/widgets/custom_apoc_feature_set/#napari_ndev._apoc_feature_stack.ApocFeatureStack","title":"ApocFeatureStack","text":"<p>               Bases: <code>Container</code></p> <p>Create and apply image features in the napari viewer.</p> <p>Parameters:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer instance to which this feature stack is attached. Default is None.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>_viewer</code>               (<code>Viewer or None</code>)           \u2013            <p>The napari viewer instance.</p> </li> <li> <code>_original</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox to keep the original image.</p> </li> <li> <code>_gaussian_blur</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Gaussian Blur parameters.</p> </li> <li> <code>_DoG</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Difference of Gaussian parameters.</p> </li> <li> <code>_LoG</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Laplacian of Gaussian parameters.</p> </li> <li> <code>_SoG</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Sobel of Gaussian parameters.</p> </li> <li> <code>_sHoG</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Small Hessian of Gaussian parameters.</p> </li> <li> <code>_lHoG</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Large Hessian of Gaussian parameters.</p> </li> <li> <code>_median</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Median filter parameters.</p> </li> <li> <code>_tophat</code>               (<code>LineEdit</code>)           \u2013            <p>LineEdit for specifying Top Hat filter parameters.</p> </li> <li> <code>_generate_string_button</code>               (<code>PushButton</code>)           \u2013            <p>Button to generate the feature string.</p> </li> <li> <code>_feature_string</code>               (<code>TextEdit</code>)           \u2013            <p>TextEdit to display the custom feature string.</p> </li> <li> <code>_image_layer</code>               (<code>ComboBox</code>)           \u2013            <p>ComboBox to select the image layer.</p> </li> <li> <code>_apply_button</code>               (<code>PushButton</code>)           \u2013            <p>Button to apply the feature stack to the selected image.</p> </li> <li> <code>_progress_bar</code>               (<code>ProgressBar</code>)           \u2013            <p>Progress bar to display the progress of feature application.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>_filter_layers</code>             \u2013              <p>Filters the layers in the viewer by the specified layer type.</p> </li> <li> <code>_update_layer_choices</code>             \u2013              <p>Updates the choices in the image layer ComboBox.</p> </li> <li> <code>generate_feature_string</code>             \u2013              <p>Generates a feature string based on the user inputs.</p> </li> <li> <code>layer_to_feature_stack</code>             \u2013              <p>Applies the generated feature stack to the selected image layer.</p> </li> </ul> Source code in <code>src/napari_ndev/_apoc_feature_stack.py</code> <pre><code>class ApocFeatureStack(Container):\n    \"\"\"Create and apply image features in the napari viewer.\n\n    Parameters\n    ----------\n    viewer : napari.viewer.Viewer, optional\n        The napari viewer instance to which this feature stack is attached. Default is None.\n\n    Attributes\n    ----------\n    _viewer : napari.viewer.Viewer or None\n        The napari viewer instance.\n    _original : CheckBox\n        Checkbox to keep the original image.\n    _gaussian_blur : LineEdit\n        LineEdit for specifying Gaussian Blur parameters.\n    _DoG : LineEdit\n        LineEdit for specifying Difference of Gaussian parameters.\n    _LoG : LineEdit\n        LineEdit for specifying Laplacian of Gaussian parameters.\n    _SoG : LineEdit\n        LineEdit for specifying Sobel of Gaussian parameters.\n    _sHoG : LineEdit\n        LineEdit for specifying Small Hessian of Gaussian parameters.\n    _lHoG : LineEdit\n        LineEdit for specifying Large Hessian of Gaussian parameters.\n    _median : LineEdit\n        LineEdit for specifying Median filter parameters.\n    _tophat : LineEdit\n        LineEdit for specifying Top Hat filter parameters.\n    _generate_string_button : PushButton\n        Button to generate the feature string.\n    _feature_string : TextEdit\n        TextEdit to display the custom feature string.\n    _image_layer : ComboBox\n        ComboBox to select the image layer.\n    _apply_button : PushButton\n        Button to apply the feature stack to the selected image.\n    _progress_bar : ProgressBar\n        Progress bar to display the progress of feature application.\n\n    Methods\n    -------\n    _filter_layers(layer_type)\n        Filters the layers in the viewer by the specified layer type.\n    _update_layer_choices()\n        Updates the choices in the image layer ComboBox.\n    generate_feature_string()\n        Generates a feature string based on the user inputs.\n    layer_to_feature_stack()\n        Applies the generated feature stack to the selected image layer.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        viewer: 'napari.viewer.Viewer' = None,\n    ):\n        super().__init__()\n        self._viewer = viewer if viewer is not None else None\n\n        self._original = CheckBox(label='Keep Original Image')\n        self._gaussian_blur = LineEdit(label='Gaussian Blur')\n        self._DoG = LineEdit(label='Difference of Gauss.')\n        self._LoG = LineEdit(label='Laplacian of Gauss.')\n        self._SoG = LineEdit(label='Sobel of Gauss.')\n        self._sHoG = LineEdit(label='Small Hessian of Gauss.')\n        self._lHoG = LineEdit(label='Large Hessian of Gauss.')\n        self._median = LineEdit(label='Median')\n        self._tophat = LineEdit(label='Top Hat')\n\n        self._generate_string_button = PushButton(\n            label='Generate Feature String'\n        )\n        self._feature_string = TextEdit(label='Custom Feature String')\n\n        self._image_layer = ComboBox(\n            choices=self._filter_layers(layers.Image), label='Image Layer'\n        )\n        self._apply_button = PushButton(label='Apply to selected image')\n        self._progress_bar = ProgressBar(label='Progress: ')\n\n        self.extend(\n            [\n                self._original,\n                self._gaussian_blur,\n                self._DoG,\n                self._LoG,\n                self._SoG,\n                self._sHoG,\n                self._lHoG,\n                self._median,\n                self._tophat,\n                self._generate_string_button,\n                self._feature_string,\n                self._image_layer,\n                self._apply_button,\n                self._progress_bar,\n            ]\n        )\n\n        self._generate_string_button.clicked.connect(\n            self.generate_feature_string\n        )\n        self._apply_button.clicked.connect(self.layer_to_feature_stack)\n\n        if self._viewer is not None:\n            self._viewer.layers.events.removed.connect(\n                self._update_layer_choices\n            )\n            self._viewer.layers.events.inserted.connect(\n                self._update_layer_choices\n            )\n\n    def _filter_layers(self, layer_type):\n        if self._viewer is None:\n            return []\n        return [x for x in self._viewer.layers if isinstance(x, layer_type)]\n\n    def _update_layer_choices(self):\n        self._image_layer.choices = self._filter_layers(layers.Image)\n\n    def generate_feature_string(self):\n        def process_feature(prefix, input_str):\n            return [\n                prefix + num.strip()\n                for num in input_str.split(',')\n                if num.strip()\n            ]\n\n        feature_list = []\n        if self._original.value:\n            feature_list.append('original')\n        feature_list.extend(\n            process_feature('gaussian_blur=', self._gaussian_blur.value)\n        )\n        feature_list.extend(\n            process_feature('difference_of_gaussian=', self._DoG.value)\n        )\n        feature_list.extend(\n            process_feature('laplace_box_of_gaussian_blur=', self._LoG.value)\n        )\n        feature_list.extend(\n            process_feature('sobel_of_gaussian_blur=', self._SoG.value)\n        )\n        feature_list.extend(\n            process_feature(\n                'small_hessian_eigenvalue_of_gaussian_blur=', self._sHoG.value\n            )\n        )\n        feature_list.extend(\n            process_feature(\n                'large_hessian_eigenvalue_of_gaussian_blur=',\n                self._lHoG.value,\n            )\n        )\n        feature_list.extend(\n            process_feature('median_sphere=', self._median.value)\n        )\n        feature_list.extend(\n            process_feature('top_hat_sphere=', self._tophat.value)\n        )\n\n        self._feature_string.value = ' '.join(feature_list)\n\n    def layer_to_feature_stack(self):\n        from apoc import generate_feature_stack\n\n        image = self._image_layer.value.data\n        feature_stack = generate_feature_stack(\n            image, self._feature_string.value\n        )\n\n        feature_strings = self._feature_string.value.split()\n\n        self._progress_bar.max = len(feature_stack)\n        self._progress_bar.value = 0\n\n        for idx, (feature, string) in enumerate(\n            zip(reversed(feature_stack), reversed(feature_strings))\n        ):\n            self._viewer.add_image(data=feature, name=string)\n            self._progress_bar.value = idx + 1\n</code></pre>"},{"location":"api/widgets/image_utilities/","title":"Image utilities","text":""},{"location":"api/widgets/image_utilities/#napari_ndev._utilities_container","title":"napari_ndev._utilities_container","text":""},{"location":"api/widgets/image_utilities/#napari_ndev._utilities_container.UtilitiesContainer","title":"UtilitiesContainer","text":"<p>               Bases: <code>Container</code></p> <p>A widget to work with images and labels in the napari viewer.</p> <p>Parameters:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer instance.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>_viewer</code>               (<code>Viewer</code>)           \u2013            <p>The napari viewer instance.</p> </li> <li> <code>_img_data</code>               (<code>ndarray or None</code>)           \u2013            <p>The concatenated image data.</p> </li> <li> <code>_image_save_dims</code>               (<code>str or None</code>)           \u2013            <p>The dimension order for saving images.</p> </li> <li> <code>_label_save_dims</code>               (<code>str or None</code>)           \u2013            <p>The dimension order for saving labels.</p> </li> <li> <code>_p_sizes</code>               (<code>PhysicalPixelSizes</code>)           \u2013            <p>The physical pixel sizes for the image.</p> </li> <li> <code>_files</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting file(s).</p> </li> <li> <code>_open_image_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for opening images.</p> </li> <li> <code>_save_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting the save directory.</p> </li> <li> <code>_save_name</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for entering the file save name.</p> </li> <li> <code>_metadata_from_selected_layer</code>               (<code>PushButton</code>)           \u2013            <p>Button for updating metadata from the selected layer.</p> </li> <li> <code>_dim_order</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for entering the dimension order.</p> </li> <li> <code>_channel_names</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for entering the channel names.</p> </li> <li> <code>_physical_pixel_sizes_z</code>               (<code>FloatSpinBox</code>)           \u2013            <p>Widget for entering the Z pixel size in micrometers.</p> </li> <li> <code>_physical_pixel_sizes_y</code>               (<code>FloatSpinBox</code>)           \u2013            <p>Widget for entering the Y pixel size in micrometers.</p> </li> <li> <code>_physical_pixel_sizes_x</code>               (<code>FloatSpinBox</code>)           \u2013            <p>Widget for entering the X pixel size in micrometers.</p> </li> <li> <code>_image_layer</code>               (<code>Select</code>)           \u2013            <p>Widget for selecting the image layer.</p> </li> <li> <code>_concatenate_image_files</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox for concatenating image files.</p> </li> <li> <code>_concatenate_image_layers</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox for concatenating image layers.</p> </li> <li> <code>_save_image_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for saving images.</p> </li> <li> <code>_labels_layer</code>               (<code>Widget</code>)           \u2013            <p>Widget for working with labels layer.</p> </li> <li> <code>_save_labels_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for saving labels.</p> </li> <li> <code>_shapes_layer</code>               (<code>Widget</code>)           \u2013            <p>Widget for working with shapes layer.</p> </li> <li> <code>_save_shapes_button</code>               (<code>PushButton</code>)           \u2013            <p>Button for saving shapes as labels.</p> </li> <li> <code>_results</code>               (<code>TextEdit</code>)           \u2013            <p>Widget for displaying information.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>_update_metadata</code>             \u2013              <p>Update the metadata based on the given image.</p> </li> <li> <code>update_metadata_from_file</code>             \u2013              <p>Update the metadata from the selected file.</p> </li> <li> <code>update_metadata_from_layer</code>             \u2013              <p>Update the metadata from the selected layer.</p> </li> <li> <code>open_images</code>             \u2013              <p>Open the selected images in the napari viewer.</p> </li> <li> <code>concatenate_images</code>             \u2013              <p>Concatenate the image data based on the selected options.</p> </li> <li> <code>p_sizes</code>             \u2013              <p>Get the physical pixel sizes.</p> </li> <li> <code>_get_save_loc</code>             \u2013              <p>Get the save location based on the parent directory.</p> </li> <li> <code>_common_save_logic</code>             \u2013              <p>Common logic for saving data as OME-TIFF.</p> </li> <li> <code>save_ome_tiff</code>             \u2013              <p>Save the concatenated image data as OME-TIFF.</p> </li> <li> <code>save_labels</code>             \u2013              <p>Save the labels data.</p> </li> <li> <code>save_shapes_as_labels</code>             \u2013              <p>Save the shapes data as labels.</p> </li> </ul> Source code in <code>src/napari_ndev/_utilities_container.py</code> <pre><code>class UtilitiesContainer(Container):\n    \"\"\"A widget to work with images and labels in the napari viewer.\n\n    Parameters\n    ----------\n    viewer: napari.viewer.Viewer, optional\n        The napari viewer instance.\n\n    Attributes\n    ----------\n    _viewer: napari.viewer.Viewer\n        The napari viewer instance.\n    _img_data: numpy.ndarray or None\n        The concatenated image data.\n    _image_save_dims: str or None\n        The dimension order for saving images.\n    _label_save_dims: str or None\n        The dimension order for saving labels.\n    _p_sizes: PhysicalPixelSizes\n        The physical pixel sizes for the image.\n    _files: FileEdit\n        Widget for selecting file(s).\n    _open_image_button: PushButton\n        Button for opening images.\n    _save_directory: FileEdit\n        Widget for selecting the save directory.\n    _save_name: LineEdit\n        Widget for entering the file save name.\n    _metadata_from_selected_layer: PushButton\n        Button for updating metadata from the selected layer.\n    _dim_order: LineEdit\n        Widget for entering the dimension order.\n    _channel_names: LineEdit\n        Widget for entering the channel names.\n    _physical_pixel_sizes_z: FloatSpinBox\n        Widget for entering the Z pixel size in micrometers.\n    _physical_pixel_sizes_y: FloatSpinBox\n        Widget for entering the Y pixel size in micrometers.\n    _physical_pixel_sizes_x: FloatSpinBox\n        Widget for entering the X pixel size in micrometers.\n    _image_layer: Select\n        Widget for selecting the image layer.\n    _concatenate_image_files: CheckBox\n        Checkbox for concatenating image files.\n    _concatenate_image_layers: CheckBox\n        Checkbox for concatenating image layers.\n    _save_image_button: PushButton\n        Button for saving images.\n    _labels_layer: Widget\n        Widget for working with labels layer.\n    _save_labels_button: PushButton\n        Button for saving labels.\n    _shapes_layer: Widget\n        Widget for working with shapes layer.\n    _save_shapes_button: PushButton\n        Button for saving shapes as labels.\n    _results: TextEdit\n        Widget for displaying information.\n\n    Methods\n    -------\n    _update_metadata(img)\n        Update the metadata based on the given image.\n    update_metadata_from_file()\n        Update the metadata from the selected file.\n    update_metadata_from_layer()\n        Update the metadata from the selected layer.\n    open_images()\n        Open the selected images in the napari viewer.\n    concatenate_images(concatenate_files, files, concatenate_layers, layers)\n        Concatenate the image data based on the selected options.\n    p_sizes()\n        Get the physical pixel sizes.\n    _get_save_loc(parent)\n        Get the save location based on the parent directory.\n    _common_save_logic(data, uri, dim_order, channel_names, layer)\n        Common logic for saving data as OME-TIFF.\n    save_ome_tiff()\n        Save the concatenated image data as OME-TIFF.\n    save_labels()\n        Save the labels data.\n    save_shapes_as_labels()\n        Save the shapes data as labels.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        viewer: napari.viewer.Viewer = None,\n    ):\n        super().__init__()\n\n        self._viewer = viewer if viewer is not None else None\n        self._img_data = None\n        self._image_save_dims = None\n        self._label_save_dims = None\n        self._p_sizes = None\n        self._squeezed_dims = None\n\n        self._file_metadata_update = PushButton(label='File')\n        self._layer_metadata_update = PushButton(label='Selected Layer')\n        self._metadata_container = Container(\n            layout='horizontal', label='Update Metadata from'\n        )\n        self._metadata_container.append(self._layer_metadata_update)\n        self._metadata_container.append(self._file_metadata_update)\n\n        self._files = FileEdit(\n            label='File(s)',\n            mode='rm',\n            tooltip='Select file(s) to load.',\n        )\n        self._open_image_update_metadata = CheckBox(\n            value=True,\n            label='Update Metadata',\n            tooltip='Update metadata during initial file selection.',\n        )\n        self._open_image_button = PushButton(label='Open File(s)')\n        self._open_next_image_button = PushButton(\n            label='Open Next',\n            tooltip='Open the next file(s) in the directory. '\n            'The files are sorted alphabetically, which may not be consistent '\n            'with your file viewer. But, opening related consecutive files '\n            'should work as expected.',\n        )\n\n        self._open_image_container = Container(layout='horizontal')\n        self._open_image_container.append(self._open_image_update_metadata)\n        self._open_image_container.append(self._open_image_button)\n        self._open_image_container.append(self._open_next_image_button)\n\n        self._save_directory = FileEdit(\n            label='Save Directory',\n            mode='d',\n            tooltip='Directory where images will be saved.',\n        )\n        self._save_name = LineEdit(\n            label='File Save Name',\n            tooltip='Name of saved file. Helpful to include a'\n            '.ome/.tif/.tiff extension.',\n        )\n\n        self._dim_order = Label(\n            label='Dimension Order: ',\n            tooltip='Sanity check for available dimensions.',\n        )\n        self._scenes = Label(\n            label='Number of Scenes: ',\n        )\n        self._info_container = Container(layout='horizontal')\n        self._info_container.append(self._dim_order)\n        self._info_container.append(self._scenes)\n\n        self._channel_names = LineEdit(\n            label='Channel Name(s)',\n            tooltip='Enter channel names as a list. If left blank or the '\n            'channel names are not the proper length, then default channel '\n            'names will be used.',\n        )\n\n        self._scale_tuple = TupleEdit(\n            value=(0.0000, 1.0000, 1.0000),\n            label='Scale, ZYX',\n            tooltip='Pixel size, usually in \u03bcm',\n            options={'step': 0.0001},\n        )\n        self._scale_layers = PushButton(\n            label='Scale Layer(s)',\n            tooltip='Scale the selected layer(s) based on the given scale.',\n        )\n        self._scale_container = Container(\n            layout='horizontal',\n            label='Scale Selected',\n        )\n        self._scale_container.append(self._scale_layers)\n\n        self._scenes_to_extract = LineEdit(\n            # label=\"Scenes to Extract\",\n            tooltip='Enter the scenes to extract as a list. If left blank '\n            'then all scenes will be extracted.',\n        )\n        self._extract_scenes = PushButton(\n            label='Extract and Save Scenes',\n            tooltip='Extract scenes from a single selected file.',\n        )\n        self._scene_container = Container(\n            layout='horizontal',\n            label='Extract Scenes',\n            tooltip='Must be in list index format. Ex: [0, 1, 2] or [5:10]',\n        )\n        self._scene_container.append(self._scenes_to_extract)\n        self._scene_container.append(self._extract_scenes)\n\n        self._concatenate_image_files = CheckBox(\n            value=True,\n            label='Concatenate Files',\n            tooltip='Concatenate files in the selected directory. Removes '\n            'blank channels.',\n        )\n        self._concatenate_image_layers = CheckBox(\n            label='Concatenate Image Layers',\n            tooltip='Concatenate image layers in the viewer. Removes empty.',\n        )\n        self._concatenate_container = Container(\n            layout='horizontal',\n            label='Image Save Options',\n        )\n        self._concatenate_container.append(self._concatenate_image_files)\n        self._concatenate_container.append(self._concatenate_image_layers)\n\n        self._save_image_button = PushButton(\n            label='Images',\n            tooltip='Save the concatenated image data as OME-TIFF.',\n        )\n        self._save_labels_button = PushButton(\n            label='Labels', tooltip='Save the labels data as OME-TIFF.'\n        )\n        self._save_shapes_button = PushButton(\n            label='Shapes as Labels',\n            tooltip='Save the shapes data as labels (OME-TIFF) according to '\n            'selected image layer dimensions.',\n        )\n        self._save_container = Container(\n            layout='horizontal',\n            label='Save Selected Layers',\n        )\n        self._save_container.append(self._save_image_button)\n        self._save_container.append(self._save_labels_button)\n        self._save_container.append(self._save_shapes_button)\n\n        self._results = TextEdit(label='Info')\n\n        # Container Widget Order\n        self.extend(\n            [\n                self._save_directory,\n                self._files,\n                self._open_image_container,\n                self._save_name,\n                self._metadata_container,\n                self._info_container,\n                self._channel_names,\n                self._scale_tuple,\n                self._scale_container,\n                self._scene_container,\n                self._concatenate_container,\n                self._save_container,\n                self._results,\n            ]\n        )\n\n        self._files.changed.connect(self.update_metadata_from_file)\n        self._open_image_button.clicked.connect(self.open_images)\n        self._open_next_image_button.clicked.connect(self.open_next_images)\n        self._layer_metadata_update.clicked.connect(\n            self.update_metadata_from_layer\n        )\n        self._file_metadata_update.clicked.connect(\n            self.update_metadata_from_file\n        )\n        self._scale_layers.clicked.connect(self.rescale_by)\n        self._extract_scenes.clicked.connect(self.save_scenes_ome_tiff)\n        self._save_image_button.clicked.connect(self.save_ome_tiff)\n        self._save_labels_button.clicked.connect(self.save_labels)\n        self._save_shapes_button.clicked.connect(self.save_shapes_as_labels)\n        self._results._on_value_change()\n\n    def _update_metadata(self, img: AICSImage):\n        self._dim_order.value = img.dims.order\n\n        self._squeezed_dims = helpers.get_squeezed_dim_order(img)\n        self._channel_names.value = helpers.get_channel_names(img)\n\n        self._scale_tuple.value = (\n            img.physical_pixel_sizes.Z or 1,\n            img.physical_pixel_sizes.Y or 1,\n            img.physical_pixel_sizes.X or 1,\n        )\n\n    def _bioimage_metadata(self):\n        from aicsimageio import AICSImage\n\n        img = AICSImage(self._files.value[0])\n        self._img = img\n        self._update_metadata(img)\n        self._scenes.value = len(img.scenes)\n\n    def update_metadata_from_file(self):\n        self._save_name.value = str(self._files.value[0].stem + '.tiff')\n\n        if self._open_image_update_metadata.value:\n            self._bioimage_metadata()\n\n    def update_metadata_from_layer(self):\n        selected_layer = self._viewer.layers.selection.active\n        try:\n            self._update_metadata(selected_layer.metadata['aicsimage'])\n        except AttributeError:\n            self._results.value = (\n                'Tried to update metadata, but no layer selected.'\n            )\n        except KeyError:\n            scale = selected_layer.scale\n            self._scale_tuple.value = (\n                scale[-3] if len(scale) &gt;= 3 else 1,\n                scale[-2],\n                scale[-1],\n            )\n            self._results.value = (\n                'Tried to update metadata, but could only update scale'\n                ' because layer not opened with aicsimageio'\n            )\n\n    def open_images(self):\n        self._viewer.open(self._files.value, plugin='napari-aicsimageio')\n\n    def open_next_images(self):\n        num_files = self._files.value.__len__()\n        # get the parent directory of the first file\n        first_file = self._files.value[0]\n        parent_dir = first_file.parent\n        # get the list of files in the parent directory\n        files = list(parent_dir.glob(f'*{first_file.suffix}'))\n        # get the index of the first file in the list\n        idx = files.index(first_file)\n        # get the next file(s) in the list after the number of files\n        next_files = files[idx + num_files : idx + num_files + num_files]\n        # set the nwe save names, and update the file value\n        self._save_name.value = str(next_files[0].stem + '.tiff')\n        self._files.value = next_files\n        if self._open_image_update_metadata.value:\n            self._bioimage_metadata()\n\n        self._viewer.open(next_files, plugin='napari-aicsimageio')\n\n    def rescale_by(self):\n        layers = self._viewer.layers.selection\n        scale_tup = self._scale_tuple.value\n\n        for layer in layers:\n            scale_len = len(layer.scale)\n            # get the scale_tup from the back of the tuple first, in case dims\n            # are missing in the new layer\n            layer.scale = scale_tup[-scale_len:]\n\n    def concatenate_images(\n        self,\n        concatenate_files: bool,\n        files: list[str | Path],\n        concatenate_layers: bool,\n        layers: list[ImageLayer],\n    ):\n        from aicsimageio import AICSImage\n\n        array_list = []\n        if concatenate_files:\n            for file in files:\n                img = AICSImage(file)\n                if 'S' in img.dims.order:\n                    img_data = img.get_image_data('TSZYX')\n                else:\n                    img_data = img.data\n\n                # iterate over all channels and only keep if not blank\n                for idx in range(img_data.shape[1]):\n                    array = img_data[:, [idx], :, :, :]\n                    if array.max() &gt; 0:\n                        array_list.append(array)\n\n        # &lt;- fix if RGB image is the layer data\n        if concatenate_layers:\n            for layer in layers:\n                layer_data = layer.data\n                # convert to 5D array for compatability with image dims\n                while len(layer_data.shape) &lt; 5:\n                    layer_data = np.expand_dims(layer_data, axis=0)\n                array_list.append(layer_data)\n\n        return np.concatenate(array_list, axis=1)\n\n    @property\n    def p_sizes(self):\n        from aicsimageio.types import PhysicalPixelSizes\n\n        return PhysicalPixelSizes(\n            self._scale_tuple.value[0],\n            self._scale_tuple.value[1],\n            self._scale_tuple.value[2],\n        )\n\n    def _get_save_loc(self, parent):\n        save_directory = self._save_directory.value / parent\n        save_directory.mkdir(parents=False, exist_ok=True)\n        return save_directory / self._save_name.value\n\n    def _common_save_logic(\n        self,\n        data: np.ndarray,\n        uri: Path,\n        dim_order: str,\n        channel_names: list[str],\n        layer: str,\n    ) -&gt; None:\n        from aicsimageio.writers import OmeTiffWriter\n\n        # AICSImage does not allow saving labels as np.int64\n        # napari generates labels differently depending on the OS\n        # so we need to convert to np.int32 in case np.int64 generated\n        # see: https://github.com/napari/napari/issues/5545\n        # This is a failsafe\n        if data.dtype == np.int64:\n            data = data.astype(np.int32)\n\n        try:\n            OmeTiffWriter.save(\n                data=data,\n                uri=uri,\n                dim_order=dim_order or None,\n                channel_names=channel_names or None,\n                physical_pixel_sizes=self.p_sizes,\n            )\n            self._results.value = f'Saved {layer}: ' + str(\n                self._save_name.value\n            )\n        # if ValueError is raised, save with default channel names\n        except ValueError as e:\n            OmeTiffWriter.save(\n                data=data,\n                uri=uri,\n                dim_order=dim_order,\n                physical_pixel_sizes=self.p_sizes,\n            )\n            self._results.value = (\n                'ValueError: '\n                + str(e)\n                + '\\nSo, saved with default channel names: \\n'\n                + str(self._save_name.value)\n            )\n        return\n\n    def save_scenes_ome_tiff(self) -&gt; None:\n        from aicsimageio import AICSImage\n\n        img = AICSImage(self._files.value[0])\n        scenes = self._scenes_to_extract.value\n        scenes_list = ast.literal_eval(scenes) if scenes else None\n        save_directory = self._save_directory.value / 'Images'\n        save_directory.mkdir(parents=False, exist_ok=True)\n        for scene in scenes_list:\n            img.set_scene(scene)\n\n            img_save_name = (\n                f'{self._save_name.value.split(\".\")[0]}'\n                f\"_scene_{img.current_scene}.ome.tiff\"\n            )\n            img_save_loc = save_directory / img_save_name\n\n            # get channel names from widget if truthy\n            cnames = self._channel_names.value\n            channel_names = ast.literal_eval(cnames) if cnames else None\n\n            self._common_save_logic(\n                data=img.data,\n                uri=img_save_loc,\n                dim_order='TCZYX',\n                channel_names=channel_names,\n                layer=f'Scene: {img.current_scene}',\n            )\n        return\n\n    def save_ome_tiff(self) -&gt; None:\n        self._img_data = self.concatenate_images(\n            self._concatenate_image_files.value,\n            self._files.value,\n            self._concatenate_image_layers.value,\n            list(self._viewer.layers.selection),\n        )\n        img_save_loc = self._get_save_loc('Images')\n        # get channel names from widget if truthy\n        cnames = self._channel_names.value\n        channel_names = ast.literal_eval(cnames) if cnames else None\n\n        self._common_save_logic(\n            data=self._img_data,\n            uri=img_save_loc,\n            dim_order='TCZYX',\n            channel_names=channel_names,\n            layer='Image',\n        )\n        return self._img_data\n\n    def save_labels(self) -&gt; None:\n        label_data = self._viewer.layers.selection.active.data\n\n        if label_data.max() &gt; 65535:\n            label_data = label_data.astype(np.int32)\n        else:\n            label_data = label_data.astype(np.int16)\n\n        label_save_loc = self._get_save_loc('Labels')\n\n        self._common_save_logic(\n            data=label_data,\n            uri=label_save_loc,\n            dim_order=self._squeezed_dims,\n            channel_names=['Labels'],\n            layer='Labels',\n        )\n        return label_data\n\n    def save_shapes_as_labels(self) -&gt; None:\n        from napari.layers import Image as ImageLayer\n\n        # inherit shape from selected image layer or else a default\n        image_layers = [\n            x for x in self._viewer.layers if isinstance(x, ImageLayer)\n        ]\n        label_dim = image_layers[0].data.shape\n\n        # drop last axis if represents RGB image\n        label_dim = label_dim[:-1] if label_dim[-1] == 3 else label_dim\n\n        shapes = self._viewer.layers.selection.active\n        shapes_as_labels = shapes.to_labels(labels_shape=label_dim)\n        shapes_as_labels = shapes_as_labels.astype(np.int16)\n\n        shapes_save_loc = self._get_save_loc('ShapesAsLabels')\n\n        self._common_save_logic(\n            data=shapes_as_labels,\n            uri=shapes_save_loc,\n            dim_order=self._squeezed_dims,\n            channel_names=['Shapes'],\n            layer='Shapes',\n        )\n\n        return shapes_as_labels\n</code></pre>"},{"location":"api/widgets/measure_widget/","title":"Measure widget","text":""},{"location":"api/widgets/measure_widget/#napari_ndev._measure_container","title":"napari_ndev._measure_container","text":""},{"location":"api/widgets/measure_widget/#napari_ndev._measure_container.MeasureContainer","title":"MeasureContainer","text":"<p>               Bases: <code>Container</code></p> <p>Widget to measure labels from folders.</p> <p>This class provides functionality to measure labels and compare them against intensity images, which can be microscopic images or other labels. It initializes various widgets and containers for user input and interaction, and connects events to handle user actions.</p> <p>Parameters:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer instance. Optional.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>)           \u2013            <p>The napari viewer instance.</p> </li> <li> <code>_label_choices</code>               (<code>list</code>)           \u2013            <p>List of label choices.</p> </li> <li> <code>_intensity_choices</code>               (<code>list</code>)           \u2013            <p>List of intensity image choices.</p> </li> <li> <code>_p_sizes</code>               (<code>None</code>)           \u2013            <p>Placeholder for pixel sizes.</p> </li> <li> <code>_squeezed_dims</code>               (<code>None</code>)           \u2013            <p>Placeholder for squeezed dimensions.</p> </li> <li> <code>_prop</code>               (<code>object</code>)           \u2013            <p>Dynamic object to hold region properties checkboxes.</p> </li> <li> <code>_label_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting label directory.</p> </li> <li> <code>_image_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting image directory.</p> </li> <li> <code>_region_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting region directory.</p> </li> <li> <code>_output_directory</code>               (<code>FileEdit</code>)           \u2013            <p>Widget for selecting output directory.</p> </li> <li> <code>_label_image</code>               (<code>ComboBox</code>)           \u2013            <p>Widget for selecting label image.</p> </li> <li> <code>_intensity_images</code>               (<code>Select</code>)           \u2013            <p>Widget for selecting intensity images.</p> </li> <li> <code>_scale_tuple</code>               (<code>TupleEdit</code>)           \u2013            <p>Widget for setting physical pixel sizes.</p> </li> <li> <code>_measure_button</code>               (<code>PushButton</code>)           \u2013            <p>Button to start measurement.</p> </li> <li> <code>_progress_bar</code>               (<code>ProgressBar</code>)           \u2013            <p>Progress bar to show measurement progress.</p> </li> <li> <code>_props_container</code>               (<code>Container</code>)           \u2013            <p>Container for region properties checkboxes.</p> </li> <li> <code>_sk_props</code>               (<code>list</code>)           \u2013            <p>List of region properties.</p> </li> <li> <code>_id_regex_container</code>               (<code>Container</code>)           \u2013            <p>Container for ID regex settings.</p> </li> <li> <code>_example_id_string</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for example ID string.</p> </li> <li> <code>_id_regex_dict</code>               (<code>TextEdit</code>)           \u2013            <p>Widget for ID regex dictionary.</p> </li> <li> <code>_tx_map_container</code>               (<code>Container</code>)           \u2013            <p>Container for treatment map settings.</p> </li> <li> <code>_tx_id</code>               (<code>LineEdit</code>)           \u2013            <p>Widget for treatment ID.</p> </li> <li> <code>_tx_n_well</code>               (<code>ComboBox</code>)           \u2013            <p>Widget for number of wells.</p> </li> <li> <code>_tx_dict</code>               (<code>TextEdit</code>)           \u2013            <p>Widget for treatment dictionary.</p> </li> <li> <code>_grouping_container</code>               (<code>Container</code>)           \u2013            <p>Container for grouping settings.</p> </li> <li> <code>_create_grouped</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox to create grouped data.</p> </li> <li> <code>_group_by_sample_id</code>               (<code>CheckBox</code>)           \u2013            <p>Checkbox to group by sample ID.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>_init_widgets</code>             \u2013              <p>Initializes the widgets for user input.</p> </li> <li> <code>_init_regionprops_container</code>             \u2013              <p>Initializes the container for region properties checkboxes.</p> </li> <li> <code>_init_id_regex_container</code>             \u2013              <p>Initializes the container for ID regex settings.</p> </li> <li> <code>_init_tx_map_container</code>             \u2013              <p>Initializes the container for treatment map settings.</p> </li> <li> <code>_init_grouping_container</code>             \u2013              <p>Initializes the container for grouping settings.</p> </li> <li> <code>_init_layout</code>             \u2013              <p>Initializes the layout of the container.</p> </li> <li> <code>_connect_events</code>             \u2013              <p>Connects events to handle user actions.</p> </li> <li> <code>_get_0th_img_from_dir</code>             \u2013              <p>Gets the first image from a directory.</p> </li> <li> <code>_update_dim_and_scales</code>             \u2013              <p>Updates the dimensions and scales based on the image.</p> </li> <li> <code>_update_choices</code>             \u2013              <p>Updates the choices for labels and intensity images.</p> </li> <li> <code>_update_image_choices</code>             \u2013              <p>Updates the choices for intensity images.</p> </li> <li> <code>_update_label_choices</code>             \u2013              <p>Updates the choices for label images.</p> </li> <li> <code>_update_region_choices</code>             \u2013              <p>Updates the choices for region images.</p> </li> <li> <code>_safe_dict_eval</code>             \u2013              <p>Safely evaluates a dictionary string.</p> </li> <li> <code>batch_measure</code>             \u2013              <p>Performs batch measurement of labels and intensity images, and returns the measurement results as a DataFrame.</p> </li> </ul> Source code in <code>src/napari_ndev/_measure_container.py</code> <pre><code>class MeasureContainer(Container):\n    \"\"\"Widget to measure labels from folders.\n\n    This class provides functionality to measure labels and compare them against intensity images, which can be microscopic images or other labels. It initializes various widgets and containers for user input and interaction, and connects events to handle user actions.\n\n    Parameters\n    ----------\n    viewer : napari.viewer.Viewer\n        The napari viewer instance. Optional.\n\n    Attributes\n    ----------\n    viewer : napari.viewer.Viewer\n        The napari viewer instance.\n\n    _label_choices : list\n        List of label choices.\n    _intensity_choices : list\n        List of intensity image choices.\n    _p_sizes : None\n        Placeholder for pixel sizes.\n    _squeezed_dims : None\n        Placeholder for squeezed dimensions.\n    _prop : object\n        Dynamic object to hold region properties checkboxes.\n    _label_directory : FileEdit\n        Widget for selecting label directory.\n    _image_directory : FileEdit\n        Widget for selecting image directory.\n    _region_directory : FileEdit\n        Widget for selecting region directory.\n    _output_directory : FileEdit\n        Widget for selecting output directory.\n    _label_image : ComboBox\n        Widget for selecting label image.\n    _intensity_images : Select\n        Widget for selecting intensity images.\n    _scale_tuple : TupleEdit\n        Widget for setting physical pixel sizes.\n    _measure_button : PushButton\n        Button to start measurement.\n    _progress_bar : ProgressBar\n        Progress bar to show measurement progress.\n    _props_container : Container\n        Container for region properties checkboxes.\n    _sk_props : list\n        List of region properties.\n    _id_regex_container : Container\n        Container for ID regex settings.\n    _example_id_string : LineEdit\n        Widget for example ID string.\n    _id_regex_dict : TextEdit\n        Widget for ID regex dictionary.\n    _tx_map_container : Container\n        Container for treatment map settings.\n    _tx_id : LineEdit\n        Widget for treatment ID.\n    _tx_n_well : ComboBox\n        Widget for number of wells.\n    _tx_dict : TextEdit\n        Widget for treatment dictionary.\n    _grouping_container : Container\n        Container for grouping settings.\n    _create_grouped : CheckBox\n        Checkbox to create grouped data.\n    _group_by_sample_id : CheckBox\n        Checkbox to group by sample ID.\n\n    Methods\n    -------\n    _init_widgets()\n        Initializes the widgets for user input.\n    _init_regionprops_container()\n        Initializes the container for region properties checkboxes.\n    _init_id_regex_container()\n        Initializes the container for ID regex settings.\n    _init_tx_map_container()\n        Initializes the container for treatment map settings.\n    _init_grouping_container()\n        Initializes the container for grouping settings.\n    _init_layout()\n        Initializes the layout of the container.\n    _connect_events()\n        Connects events to handle user actions.\n    _get_0th_img_from_dir(directory)\n        Gets the first image from a directory.\n    _update_dim_and_scales(img)\n        Updates the dimensions and scales based on the image.\n    _update_choices(directory, prefix, update_label=False)\n        Updates the choices for labels and intensity images.\n    _update_image_choices()\n        Updates the choices for intensity images.\n    _update_label_choices()\n        Updates the choices for label images.\n    _update_region_choices()\n        Updates the choices for region images.\n    _safe_dict_eval(dict_string, dict_name=None)\n        Safely evaluates a dictionary string.\n    batch_measure()\n        Performs batch measurement of labels and intensity images, and returns the measurement results as a DataFrame.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        viewer: napari.viewer.Viewer = None,\n    ):\n        super().__init__()\n\n        self.viewer = viewer if viewer is not None else None\n        self._label_choices = []\n        self._intensity_choices = []\n        self._p_sizes = None\n        self._squeezed_dims = None\n        self._prop = type('', (), {})()\n\n        self._init_widgets()\n        self._init_regionprops_container()\n        self._init_id_regex_container()\n        self._init_tx_map_container()\n        self._init_grouping_container()\n        self._init_layout()\n        self._connect_events()\n\n    def _init_widgets(self):\n        self._label_directory = FileEdit(label='Label directory', mode='d')\n        self._image_directory = FileEdit(\n            label='Image directory', mode='d', nullable=True\n        )\n        self._region_directory = FileEdit(\n            label='Region directory', mode='d', nullable=True\n        )\n        self._output_directory = FileEdit(label='Output directory', mode='d')\n\n        self._label_image = ComboBox(\n            label='Label image',\n            choices=self._label_choices,\n            nullable=False,\n            tooltip='Select label image to measure',\n        )\n        self._intensity_images = Select(\n            label='Intensity images',\n            choices=self._intensity_choices,\n            allow_multiple=True,\n            nullable=True,\n            tooltip='Select intensity images to compare against labels',\n        )\n        self._scale_tuple = TupleEdit(\n            value=(0.0000, 1.0000, 1.0000),\n            label='Physical Pixel Sizes, ZYX',\n            tooltip='Pixel size, usually in \u03bcm/px',\n            options={'step': 0.0001},\n        )\n        self._measure_button = PushButton(label='Measure')\n\n        self._progress_bar = ProgressBar(label='Progress:')\n\n    def _init_regionprops_container(self):\n        self._props_container = Container(layout='vertical')\n\n        self._sk_props = [\n            'area',\n            'area_convex',\n            'bbox',\n            'centroid',\n            'eccentricity',\n            'extent',\n            'feret_diameter_max',\n            'intensity_max',\n            'intensity_mean',\n            'intensity_min',\n            'intensity_std',\n            'num_pixels',\n            'orientation',\n            'perimeter',\n            'solidity',\n        ]\n\n        for feature in self._sk_props:\n            setattr(self._prop, feature, CheckBox(label=feature))\n            self._props_container.extend([getattr(self._prop, feature)])\n\n        self._prop.area.value = True\n\n    def _init_id_regex_container(self):\n        self._id_regex_container = Container(layout='vertical')\n        self._example_id_string = LineEdit(\n            label='Example ID String',\n            value=None,\n            nullable=True,\n        )\n        self._id_regex_dict = TextEdit(\n            label='ID Regex Dict',\n            value='{\\n\\n}',\n        )\n        self._id_regex_container.extend(\n            [self._example_id_string, self._id_regex_dict]\n        )\n\n    def _init_tx_map_container(self):\n        self._tx_map_container = Container(layout='vertical')\n        self._tx_id = LineEdit(\n            label='Treatment ID',\n            value=None,\n            nullable=True,\n            tooltip='Usually, the treatment ID is the well ID or a unique identifier for each sample'\n            \"The treatment dict will be looked up against whatever this value is. If it is 'file', then will match against the filename\",\n        )\n        self._tx_n_well = ComboBox(\n            label='Number of Wells',\n            value=None,\n            choices=[6, 12, 24, 48, 96, 384],\n            nullable=True,\n            tooltip='By default, treatments must be verbosely defined for each condition and sample id'\n            'If you have a known plate map, then selecting wells will allow a sparse treatment map to be passed to PlateMapper',\n        )\n        self._tx_dict = TextEdit(label='Treatment Dict', value='{\\n\\n}')\n        # TODO: Add example treatment regex result widget when example id string or id regex dict is changed\n\n        self._tx_map_container.extend(\n            [self._tx_id, self._tx_n_well, self._tx_dict]\n        )\n\n    def _init_grouping_container(self):\n        self._grouping_container = Container(layout='vertical')\n        self._create_grouped = CheckBox(\n            label='Create Grouped Data',\n            value=False,\n            tooltip='If checked, will create a grouped data frame with the same properties as the original data frame',\n        )\n        self._group_by_sample_id = CheckBox(\n            label='Group by Sample ID',\n            value=True,\n            tooltip='If checked, will group the data by the id_string, which is usually the filename and scene',\n        )\n\n        self._grouping_container.extend(\n            [self._create_grouped, self._group_by_sample_id]\n        )\n\n    def _init_layout(self):\n        self.extend(\n            [\n                self._label_directory,\n                self._image_directory,\n                self._region_directory,\n                self._output_directory,\n                self._label_image,\n                self._intensity_images,\n                self._scale_tuple,\n                self._measure_button,\n                self._progress_bar,\n            ]\n        )\n\n        tabs = QTabWidget()\n        tabs.addTab(self._props_container.native, 'Region Props')\n        tabs.addTab(self._id_regex_container.native, 'ID Regex')\n        tabs.addTab(self._tx_map_container.native, 'Tx Map')\n        tabs.addTab(self._grouping_container.native, 'Grouping')\n        self.native.layout().addWidget(tabs)\n\n    def _connect_events(self):\n        self._image_directory.changed.connect(self._update_image_choices)\n        self._label_directory.changed.connect(self._update_label_choices)\n        self._region_directory.changed.connect(self._update_region_choices)\n        self._measure_button.clicked.connect(self.batch_measure)\n\n    def _get_0th_img_from_dir(\n        self, directory: str | None = None\n    ) -&gt; tuple[BioImage, pathlib.Path]:\n        from bioio import BioImage\n\n        _, files = helpers.get_directory_and_files(directory)\n        return BioImage(files[0]), files[0]\n\n    def _update_dim_and_scales(self, img):\n        self._squeezed_dims = helpers.get_squeezed_dim_order(img)\n        self._scale_tuple.value = (\n            img.physical_pixel_sizes.Z or 1,\n            img.physical_pixel_sizes.Y or 1,\n            img.physical_pixel_sizes.X or 1,\n        )\n\n    def _update_choices(self, directory, prefix, update_label=False):\n        img, _ = self._get_0th_img_from_dir(directory)\n        img_channels = helpers.get_channel_names(img)\n        img_channels = [f'{prefix}: {channel}' for channel in img_channels]\n\n        if update_label:\n            self._update_dim_and_scales(img)\n            self._label_choices.extend(img_channels)\n            self._label_image.choices = self._label_choices\n\n        self._intensity_choices.extend(img_channels)\n        self._intensity_images.choices = self._intensity_choices\n\n    def _update_image_choices(self):\n        self._update_choices(self._image_directory.value, 'Intensity')\n\n    def _update_label_choices(self):\n        self._update_choices(\n            self._label_directory.value, 'Labels', update_label=True\n        )\n        img, file_id = self._get_0th_img_from_dir(self._label_directory.value)\n        id_string = helpers.create_id_string(img, file_id.stem)\n        self._example_id_string.value = id_string\n\n    def _update_region_choices(self):\n        self._update_choices(self._region_directory.value, 'Region')\n\n    def _safe_dict_eval(self, dict_string, dict_name=None):\n        if dict_string is None:\n            return None\n\n        stripped_string = dict_string.strip()\n        if stripped_string == '{}' or not stripped_string:\n            return None\n        try:\n            return ast.literal_eval(stripped_string)\n        except (ValueError, SyntaxError):\n            return None\n\n    def batch_measure(self) -&gt; pd.DataFrame:\n        from bioio import BioImage\n\n        # from skimage import measure\n        from napari_ndev import measure as ndev_measure\n\n        # get all the files in the label directory\n        label_dir, label_files = helpers.get_directory_and_files(\n            self._label_directory.value\n        )\n        image_dir, image_files = helpers.get_directory_and_files(\n            self._image_directory.value\n        )\n        region_dir, region_files = helpers.get_directory_and_files(\n            self._region_directory.value\n        )\n\n        # check if the label files are the same as the image files\n        # if self._image_directory.value is not None:\n        #     if len(label_files) != len(image_files):\n        #         raise ValueError(\n        #             'Number of label files and image files do not match'\n        #         )\n        # if self._region_directory.value is not None:\n        #     if len(label_files) != len(region_files):\n        #         raise ValueError(\n        #             'Number of label files and region files do not match'\n        #         )\n\n        log_loc = self._output_directory.value / '.log.txt'\n        logger, handler = helpers.setup_logger(log_loc)\n\n        logger.info(\n            \"\"\"\n            Label Image: %s\n            Intensity Channels: %s\n            Num. Files: %d\n            Label Directory: %s\n            Image Directory: %s\n            Region Directory: %s\n            Output Directory: %s\n            ID Example: %s\n            ID Regex Dict: %s\n            Tx ID: %s\n            Tx N Well: %s\n            Tx Dict: %s\n            \"\"\",\n            self._label_image.value,\n            self._intensity_images.value,\n            len(label_files),\n            label_dir,\n            image_dir,\n            region_dir,\n            self._output_directory.value,\n            self._example_id_string.value,\n            self._id_regex_dict.value,\n            self._tx_id.value,\n            self._tx_n_well.value,\n            self._tx_dict.value\n        )\n\n        self._progress_bar.label = f'Measuring {len(label_files)} Images'\n        self._progress_bar.value = 0\n        self._progress_bar.max = len(label_files)\n        # get the relevant spacing for regionprops, depending on length\n        props_scale = self._scale_tuple.value\n        props_scale = props_scale[-len(self._squeezed_dims) :]\n        # get the properties list\n        properties = [\n            prop.label for prop in self._props_container if prop.value\n        ]\n\n        id_regex_dict = self._safe_dict_eval(\n            self._id_regex_dict.value, 'ID Regex Dict'\n        )\n        tx_dict = self._safe_dict_eval(self._tx_dict.value, 'Tx Dict')\n        measure_props_concat = []\n\n        for idx, file in enumerate(label_files):\n            # TODO: Add scene processing\n            logger.info('Processing file %s', file.name)\n            lbl = BioImage(label_dir / file.name)\n            id_string = helpers.create_id_string(lbl, file.stem)\n\n            label_chan = self._label_image.value[8:]\n            lbl_C = lbl.channel_names.index(label_chan)\n\n            intensity_images = []\n            intensity_names = []\n\n            # get the itnensity image only if the image directory is not empty\n            if self._image_directory.value:\n                image_path = image_dir / file.name\n                if not image_path.exists():\n                    logger.error(\n                        'Image file %s not found in intensity directory', file.name\n                    )\n                    self._progress_bar.value = idx + 1\n                    continue\n                img = BioImage(image_path)\n            if self._region_directory.value:\n                region_path = region_dir / file.name\n                if not region_path.exists():\n                    logger.error(\n                        'Region file %s not found in region directory', file.name\n                    )\n                    self._progress_bar.value = idx + 1\n                    continue\n                reg = BioImage(region_path)\n\n            for scene_idx, _scene in enumerate(lbl.scenes):\n                logger.info('Processing scene %s', scene_idx)\n                lbl.set_scene(scene_idx)\n                label = lbl.get_image_data(self._squeezed_dims, C=lbl_C)\n                id_string = helpers.create_id_string(lbl, file.stem)\n\n                # Get stack of intensity images if there are any selected\n                if self._intensity_images.value and not None:\n                    for channel in self._intensity_images.value:\n                        if channel.startswith('Labels: '):\n                            chan = channel[8:]\n                            lbl_C = lbl.channel_names.index(chan)\n                            lbl.set_scene(scene_idx)\n                            chan_img = lbl.get_image_data(\n                                self._squeezed_dims, C=lbl_C\n                            )\n                        elif channel.startswith('Intensity: '):\n                            chan = channel[11:]\n                            img_C = img.channel_names.index(chan)\n                            img.set_scene(scene_idx)\n                            chan_img = img.get_image_data(\n                                self._squeezed_dims, C=img_C\n                            )\n                        elif channel.startswith('Region: '):\n                            chan = channel[8:]\n                            reg_C = reg.channel_names.index(chan)\n                            img.set_scene(scene_idx)\n                            chan_img = reg.get_image_data(\n                                self._squeezed_dims, C=reg_C\n                            )\n                        intensity_names.append(chan)\n                        intensity_images.append(chan_img)\n\n                    # the last dim is the multi-channel dim for regionprops\n                    intensity_stack = np.stack(intensity_images, axis=-1)\n\n                else:\n                    intensity_stack = None\n                    intensity_names = None\n\n                # start the measuring here\n                # TODO: Add optional scaling, in case images have different scales?\n                measure_props_df = ndev_measure.measure_regionprops(\n                    label_images=label,\n                    label_names=label_chan,\n                    intensity_images=intensity_stack,\n                    intensity_names=intensity_names,\n                    properties=properties,\n                    scale=props_scale,\n                    id_string=id_string,\n                    id_regex_dict=id_regex_dict,\n                    tx_id=self._tx_id.value,\n                    tx_dict=tx_dict,\n                    tx_n_well=self._tx_n_well.value,\n                    save_data_path=None,\n                )\n\n                measure_props_concat.append(measure_props_df)\n                self._progress_bar.value = idx + 1\n\n        measure_props_df = pd.concat(measure_props_concat)\n        measure_props_df.to_csv(\n            self._output_directory.value / f'measure_props_{label_chan}.csv'\n        )\n\n        if self._create_grouped.value:\n            if self._group_by_sample_id.value:\n                # get count data\n                measure_props_count = (\n                    measure_props_df.groupby('id')\n                    .agg({measure_props_df.columns[0]: 'count'})\n                    .rename(\n                        columns={measure_props_df.columns[0]: 'label_count'}\n                    )\n                    .reset_index(drop=True)\n                )\n                measure_props_grouped = (\n                    measure_props_df.groupby('id')  # sw\n                    .agg(\n                        {\n                            col: ['mean', 'std']\n                            for col in measure_props_df.columns[1:]\n                        }\n                    )\n                    .reset_index()\n                )  # genereates a multi-index\n                # collapse multi index and combine columns names with '_' sep\n                measure_props_grouped.columns = [\n                    f'{col[0]}_{col[1]}' if col[1] else col[0]\n                    for col in measure_props_grouped.columns\n                ]\n\n                measure_props_grouped = pd.concat(\n                    [measure_props_grouped, measure_props_count], axis=1\n                )\n\n            measure_props_grouped.to_csv(\n                self._output_directory.value\n                / f'measure_props_grouped_{label_chan}.csv'\n            )\n        else:\n            measure_props_grouped = None\n\n        logger.removeHandler(handler)\n\n        return measure_props_df, measure_props_grouped\n</code></pre>"},{"location":"api/widgets/workflow_widget/","title":"Workflow widget","text":""},{"location":"api/widgets/workflow_widget/#napari_ndev._workflow_container","title":"napari_ndev._workflow_container","text":""},{"location":"api/widgets/workflow_widget/#napari_ndev._workflow_container.WorkflowContainer","title":"WorkflowContainer","text":"<p>               Bases: <code>Container</code></p> <p>Container class for managing the workflow functionality in napari-ndev.</p> <p>Parameters:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>)           \u2013            <p>The napari viewer instance.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>viewer</code>               (<code>Viewer</code>)           \u2013            <p>The napari viewer instance.</p> </li> <li> <code>roots</code>               (<code>list</code>)           \u2013            <p>List of ComboBox widgets representing the workflow roots.</p> </li> <li> <code>_channel_names</code>               (<code>list</code>)           \u2013            <p>List of channel names extracted from the image data.</p> </li> <li> <code>_img_dims</code>               (<code>str</code>)           \u2013            <p>The dimensions of the image data.</p> </li> </ul> Widgets: <p>image_directory : FileEdit     Widget for selecting the image directory. result_directory : FileEdit     Widget for selecting the result directory. workflow_file : FileEdit     Widget for selecting the workflow file. _keep_original_images : CheckBox     Checkbox widget for specifying whether to keep original images. batch_button : PushButton     Button widget for triggering the batch workflow. _progress_bar : ProgressBar     Progress bar widget for displaying the progress of the workflow. _workflow_roots : Label     Label widget for displaying the workflow roots.</p> Events: <p>image_directory.changed : Signal     Signal emitted when the image directory is changed. workflow_file.changed : Signal     Signal emitted when the workflow file is changed. batch_button.clicked : Signal     Signal emitted when the batch button is clicked.</p> Source code in <code>src/napari_ndev/_workflow_container.py</code> <pre><code>class WorkflowContainer(Container):\n    \"\"\"Container class for managing the workflow functionality in napari-ndev.\n\n    Parameters\n    ----------\n    viewer : napari.viewer.Viewer\n        The napari viewer instance.\n\n    Attributes\n    ----------\n    viewer : napari.viewer.Viewer\n        The napari viewer instance.\n    roots : list\n        List of ComboBox widgets representing the workflow roots.\n    _channel_names : list\n        List of channel names extracted from the image data.\n    _img_dims : str\n        The dimensions of the image data.\n\n    Widgets:\n    --------\n    image_directory : FileEdit\n        Widget for selecting the image directory.\n    result_directory : FileEdit\n        Widget for selecting the result directory.\n    workflow_file : FileEdit\n        Widget for selecting the workflow file.\n    _keep_original_images : CheckBox\n        Checkbox widget for specifying whether to keep original images.\n    batch_button : PushButton\n        Button widget for triggering the batch workflow.\n    _progress_bar : ProgressBar\n        Progress bar widget for displaying the progress of the workflow.\n    _workflow_roots : Label\n        Label widget for displaying the workflow roots.\n\n    Events:\n    -------\n    image_directory.changed : Signal\n        Signal emitted when the image directory is changed.\n    workflow_file.changed : Signal\n        Signal emitted when the workflow file is changed.\n    batch_button.clicked : Signal\n        Signal emitted when the batch button is clicked.\n\n    \"\"\"\n\n    def __init__(self, viewer: 'napari.viewer.Viewer'):\n        super().__init__()\n        ##############################\n        # Attributes\n        ##############################\n        self.viewer = viewer\n        self.roots = []\n        self._channel_names = []\n        self._img_dims = ''\n\n        ##############################\n        # Widgets\n        ##############################\n        self.image_directory = FileEdit(label='Image Directory', mode='d')\n        self.result_directory = FileEdit(label='Result Directory', mode='d')\n\n        self.workflow_file = FileEdit(\n            label='Workflow File',\n            filter='*.yaml',\n            tooltip='Select a workflow file to load',\n        )\n        self._keep_original_images = CheckBox(\n            label='Keep Original Images',\n            value=False,\n            tooltip='If checked, the original images will be '\n            'concatenated with the results',\n        )\n        self.batch_button = PushButton(label='Batch Workflow')\n\n        self._progress_bar = ProgressBar(label='Progress:')\n        self._workflow_roots = Label(label='Workflow Roots:')\n\n        self.extend(\n            [\n                self.image_directory,\n                self.result_directory,\n                self.workflow_file,\n                self._keep_original_images,\n                self.batch_button,\n                self._progress_bar,\n                self._workflow_roots,\n            ]\n        )\n        ##############################\n        # Event Handling\n        ##############################\n        self.image_directory.changed.connect(self._get_image_info)\n        # &lt;- the below will be used for single workflow, not batch\n        # self.viewer.layers.events.inserted.connect(self._update_root_choices)\n        # self.viewer.layers.events.removed.connect(self._update_root_choices)\n        self.workflow_file.changed.connect(self._get_workflow_info)\n        self.batch_button.clicked.connect(self.batch_workflow)\n\n    # Get Channel names and image dimensions without C\n    def _get_image_info(self):\n        from aicsimageio import AICSImage\n\n        self.image_dir, self.image_files = helpers.get_directory_and_files(\n            self.image_directory.value,\n        )\n        img = AICSImage(self.image_files[0])\n\n        self._channel_names = helpers.get_channel_names(img)\n        self._update_root_choices()\n        self._squeezed_img_dims = helpers.get_squeezed_dim_order(img)\n        return self._squeezed_img_dims\n\n    def _update_root_choices(self):\n        for root in self.roots:\n            root.choices = self._channel_names + self.viewer.layers\n\n    def _update_roots(self):\n        for root in self.roots:\n            self.remove(root)\n        self.roots.clear()\n\n        for idx, root in enumerate(self.workflow.roots()):\n            root = ComboBox(\n                label=f'Root {idx}: {root}',\n                choices=self._channel_names,\n                nullable=True,\n                value=None,\n            )\n            self.roots.append(root)\n            self.append(root)\n        return\n\n    def _get_workflow_info(self):\n        from napari_workflows._io_yaml_v1 import load_workflow\n\n        self.workflow = load_workflow(self.workflow_file.value)\n        self._workflow_roots.value = self.workflow.roots()\n        self._update_roots()\n        return\n\n    def batch_workflow(self):\n        import dask.array as da\n        from aicsimageio import AICSImage, transforms\n        from aicsimageio.writers import OmeTiffWriter\n\n        result_dir = self.result_directory.value\n        image_files = self.image_files\n        workflow = self.workflow\n\n        # get indexes of channel names, in case not all images have\n        # the same channel names, the index should be in the same order\n        root_list = [root.value for root in self.roots]\n        root_index_list = [self._channel_names.index(r) for r in root_list]\n\n        # Setting up Logging File\n        log_loc = result_dir / 'workflow.log.txt'\n        logger, handler = helpers.setup_logger(log_loc)\n        logger.info(\n            \"\"\"\n            Image Directory: %s\n            Result Directory: %s\n            Workflow File: %s\n            Roots: %s\n            \"\"\",\n            self.image_directory.value,\n            result_dir,\n            self.workflow_file.value,\n            root_list,\n        )\n\n        self._progress_bar.label = f'Workflow on {len(image_files)} images'\n        self._progress_bar.value = 0\n        self._progress_bar.max = len(image_files)\n\n        for idx_file, image_file in enumerate(image_files):\n            logger.info('Processing %d: %s', idx_file+1, image_file.name)\n            img = AICSImage(image_file)\n\n            root_stack = []\n            # get image corresponding to each root, and set it to the workflow\n            for idx, root_index in enumerate(root_index_list):\n                if 'S' in img.dims.order:\n                    root_img = img.get_image_data('TSZYX', S=root_index)\n                else:\n                    root_img = img.get_image_data('TCZYX', C=root_index)\n                # stack the TCZYX images for later stacking with results\n                root_stack.append(root_img)\n                # squeeze the root image for workflow\n                root_squeeze = np.squeeze(root_img)\n                # set the root image to the index of the root in the workflow\n                workflow.set(\n                    name=workflow.roots()[idx], func_or_data=root_squeeze\n                )\n\n            leaf_names = workflow.leafs()\n            result = workflow.get(name=leaf_names)\n\n            result_stack = np.asarray(\n                result\n            )  # cle.pull stacks the results on the 0th axis as \"C\"\n            # transform result_stack to TCZYX\n            result_stack = transforms.reshape_data(\n                data=result_stack,\n                given_dims='C' + self._squeezed_img_dims,\n                return_dims='TCZYX',\n            )\n\n            # &lt;- should I add a check for the result_stack to be a dask array?\n            # &lt;- should this be done using dask or numpy?\n            if self._keep_original_images.value:\n                dask_images = da.concatenate(root_stack, axis=1)  # along \"C\"\n                result_stack = da.concatenate(\n                    [dask_images, result_stack], axis=1\n                )\n                result_names = root_list + leaf_names\n            else:\n                result_names = leaf_names\n\n            OmeTiffWriter.save(\n                data=result_stack,\n                uri=result_dir / (image_file.stem + '.tiff'),\n                dim_order='TCZYX',\n                channel_names=result_names,\n                physical_pixel_sizes=img.physical_pixel_sizes,\n            )\n\n            self._progress_bar.value = idx_file + 1\n\n        logger.removeHandler(handler)\n        return\n</code></pre>"}]}