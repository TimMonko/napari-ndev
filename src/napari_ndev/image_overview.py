"""
Function and class to create and manage image overviews with stackview.

It includes a function `image_overview` to generate an overview of images
and a class `ImageOverview` to generate and save image overviews.
"""

from __future__ import annotations

import inspect

import matplotlib.pyplot as plt
import numpy as np
import stackview


class ImageOverview:
    """
    A class for generating and saving image overviews.

    Use this class to prevent a memory leak otherwise generated by the
    image_overview() function when show=True. For some reason, preventing
    the memory leak requires the use of a class instead of a function, and
    show=False.
    """

    def __init__(
        self,
        image_sets: dict | list[dict],
        fig_scale: tuple[float, float] = (3, 3),
        fig_title: str = '',
        scalebar: float | dict | None = None,
        show: bool = False,
    ):
        """
        Initialize an ImageOverivew object.

        Parameters
        ----------
        image_sets : list of dict
            A list of dictionaries containing image sets. See
            `napari_ndev.image_overview` for more information.
        fig_scale : tuple of float, optional
            The scale of the plot. (Width, Height). Values lower than 2 are likely
            to result in overlapping text. Increased values increase image size.
            Defaults to (3, 3).
        fig_title : str, optional
            The title of the image overview. Default is an empty string.
        scalebar : float or dict, optional
            The scalebar to add to the image overview. If a float, it is used as
            the dx parameter for the scalebar. If a dict, all **kwargs are passed
            to the matplotlib_scalebar.scalebar.ScaleBar class. Defaults to None.
        show : bool, optional
            Whether to display the generated overview. Default is False.
            Prevents memory leak when False.

        """
        plt.ioff()
        self.fig = image_overview(image_sets, fig_scale, fig_title, scalebar)
        if show:
            plt.show()
        plt.close()

    def save(
        self,
        directory: str | None = None,
        filename: str | None = None,
    ):
        """
        Save the generated image overview with matplotlib.savefig.

        Parameters
        ----------
        directory : str, optional
            The directory to save the image overview. If not provided, the
            current directory will be used.
        filename : str, optional
            The filename of the saved image overview. If not provided, a
            default filename will be used.

        """
        import pathlib

        path_dir = pathlib.Path(directory)
        path_dir.mkdir(parents=True, exist_ok=True)
        filepath = path_dir / filename
        self.fig.savefig(filepath)


def image_overview(
    image_sets: dict | list[dict],
    fig_scale: tuple[float, float] = (3, 3),
    fig_title: str = '',
    scalebar: float | dict | None = None,
):
    """
    Create an overview of images.

    Parameters
    ----------
    image_sets : list of dict
        A list of dictionaries, each containing an image set. Each image set
        should be a dictionary containing the following keys:
        - image (list): A list of images to display.
        - title (list of str, optional): The title of the image set.
        - colormap (list of str, optional): The colormap to use.
            "labels" will display the image as labels.
        - labels (list of bool, optional): Whether to display labels.
        - **kwargs: Additional keyword arguments to pass to stackview.imshow.
    fig_scale : tuple of float, optional
        The scale of the plot. (Width, Height). Values lower than 2 are likely
        to result in overlapping text. Increased values increase image size.
        Defaults to (3, 3).
    fig_title : str, optional
        The title of the plot. Defaults to an empty string.
    scalebar : float or dict, optional
        The scalebar to add to the image overview. If a float, it is used as
        the dx parameter for the scalebar. If a dict, all **kwargs are passed
        to the matplotlib_scalebar.scalebar.ScaleBar class. Defaults to None.

    Returns
    -------
    fig : matplotlib.figure.Figure
        The matplotlib figure object containing the image overview.

    """
    # convert input to list if needed
    image_sets = [image_sets] if isinstance(image_sets, dict) else image_sets
    # create the subplot grid

    # if only one image set, wrap rows and columns to get a nice aspect ratio
    if len(image_sets) == 1:
        num_images = len(image_sets[0]['image'])

        if num_images <= 3:
            num_columns = num_images
            num_rows = 1
        # wrap so it is roughly a square aspect ratio
        else:
            num_columns = int(np.ceil(np.sqrt(num_images)))
            num_rows = int(np.ceil(num_images / num_columns))

    if len(image_sets) > 1:
        num_rows = len(image_sets)
        num_columns = max([len(image_set['image']) for image_set in image_sets])

    # multiply scale of plot by number of columns and rows
    fig, axs = plt.subplots(
        num_rows,
        num_columns,
        figsize=(num_columns * fig_scale[0], num_rows * fig_scale[1]),
    )

    if num_rows == 1:
        axs = [axs]
    if num_columns == 1:
        axs = [[ax] for ax in axs]

    # iterate through the image sets
    for image_set_idx, image_set in enumerate(image_sets):
        for image_idx, _image in enumerate(image_set['image']):

            # calculate the correct row and column for the subplot
            if len(image_sets) == 1:
                row =  image_idx // num_columns
                col = image_idx % num_columns
            if len(image_sets) > 1:
                row = image_set_idx
                col = image_idx

            # create a dictionary from the col-th values of each key
            image_dict = {key: value[image_idx] for key, value in image_set.items()}

            # turn off the subplot and continue if there is no image
            if image_dict.get('image') is None:
                axs[row][col].axis('off')
                continue

            # create a labels key if it doesn't exist, but does in colormap
            cmap = image_dict.get('colormap')
            if cmap is not None and cmap.lower() == 'labels':
                image_dict['labels'] = True

            sv_dict = {k: v for k, v in image_dict.items() if k in inspect.signature(stackview.imshow).parameters}
            stackview.imshow(**sv_dict, plot=axs[row][col])

            # add scalebar, if dict is present
            if scalebar is not None:
                _add_scalebar(axs[row][col], scalebar)

    # remove empty subplots
    for ax in fig.get_axes():
        ax.axis('off') if not ax.get_images() else None

    plt.suptitle(fig_title, fontsize=16)
    plt.tight_layout(pad=0.3)

    return fig

def _add_scalebar(ax, scalebar):
    from matplotlib_scalebar.scalebar import ScaleBar

    # get a default dictionary to pass to sb_dict,
    # and only overwrite the keys that are present in scalebar
    sb_dict = {
        'dx': 1,
        'units': 'um',
        'frameon': True,
        'location': 'lower right',
    }

    # if scalebar is just float, convert to dict
    if isinstance(scalebar, float):
        sb_dict = {'dx': scalebar}
    # if scalebar is dict, only keep the keys that are valid for ScaleBar
    elif isinstance(scalebar, dict):
        sb_valid_dict = {k: v for k, v in scalebar.items() if k in inspect.signature(ScaleBar).parameters}
        # update key: values in sb_dict with values from scalebar if key is present
        sb_dict.update(sb_valid_dict)

    ax.add_artist(ScaleBar(**sb_dict))
